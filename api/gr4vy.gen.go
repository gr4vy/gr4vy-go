// Package Openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package Openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for APIKeyPairType.
const (
	APIKeyPairTypeApiKeyPair APIKeyPairType = "api-key-pair"
)

// Defines values for BuyerType.
const (
	BuyerTypeBuyer BuyerType = "buyer"
)

// Defines values for CardEnvironment.
const (
	CardEnvironmentDevelopment CardEnvironment = "development"

	CardEnvironmentProduction CardEnvironment = "production"

	CardEnvironmentStaging CardEnvironment = "staging"
)

// Defines values for CardMethod.
const (
	CardMethodCard CardMethod = "card"
)

// Defines values for CardStatus.
const (
	CardStatusProcessing CardStatus = "processing"

	CardStatusProcessingFailed CardStatus = "processing_failed"

	CardStatusStored CardStatus = "stored"

	CardStatusUsed CardStatus = "used"
)

// Defines values for CardType.
const (
	CardTypePaymentMethod CardType = "payment-method"
)

// Defines values for CardTokenizedMethod.
const (
	CardTokenizedMethodCard CardTokenizedMethod = "card"
)

// Defines values for CardTokenizedType.
const (
	CardTokenizedTypePaymentMethod CardTokenizedType = "payment-method"
)

// Defines values for CardDetailsScheme.
const (
	CardDetailsSchemeAmericanExpress CardDetailsScheme = "american-express"

	CardDetailsSchemeDinersClub CardDetailsScheme = "diners-club"

	CardDetailsSchemeDiscover CardDetailsScheme = "discover"

	CardDetailsSchemeElo CardDetailsScheme = "elo"

	CardDetailsSchemeHiper CardDetailsScheme = "hiper"

	CardDetailsSchemeHipercard CardDetailsScheme = "hipercard"

	CardDetailsSchemeJcb CardDetailsScheme = "jcb"

	CardDetailsSchemeMaestro CardDetailsScheme = "maestro"

	CardDetailsSchemeMastercard CardDetailsScheme = "mastercard"

	CardDetailsSchemeMir CardDetailsScheme = "mir"

	CardDetailsSchemeUnionpay CardDetailsScheme = "unionpay"

	CardDetailsSchemeVisa CardDetailsScheme = "visa"
)

// Defines values for CardRequestEnvironment.
const (
	CardRequestEnvironmentDevelopment CardRequestEnvironment = "development"

	CardRequestEnvironmentProduction CardRequestEnvironment = "production"

	CardRequestEnvironmentStaging CardRequestEnvironment = "staging"
)

// Defines values for CardRequestMethod.
const (
	CardRequestMethodCard CardRequestMethod = "card"
)

// Defines values for CardRuleEnvironment.
const (
	CardRuleEnvironmentDevelopment CardRuleEnvironment = "development"

	CardRuleEnvironmentProduction CardRuleEnvironment = "production"

	CardRuleEnvironmentStaging CardRuleEnvironment = "staging"
)

// Defines values for CardRuleInvalidRuleFallbackStrategy.
const (
	CardRuleInvalidRuleFallbackStrategyDecline CardRuleInvalidRuleFallbackStrategy = "decline"

	CardRuleInvalidRuleFallbackStrategySkip CardRuleInvalidRuleFallbackStrategy = "skip"

	CardRuleInvalidRuleFallbackStrategyUseAllProviders CardRuleInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleType.
const (
	CardRuleTypeCardRule CardRuleType = "card-rule"
)

// Defines values for CardRuleUnprocessableFallbackStrategy.
const (
	CardRuleUnprocessableFallbackStrategyDecline CardRuleUnprocessableFallbackStrategy = "decline"

	CardRuleUnprocessableFallbackStrategyUseAllProviders CardRuleUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleNumberConditionKey.
const (
	CardRuleNumberConditionKeyAmount CardRuleNumberConditionKey = "amount"
)

// Defines values for CardRuleNumberConditionMatch.
const (
	CardRuleNumberConditionMatchNumber CardRuleNumberConditionMatch = "number"
)

// Defines values for CardRuleRequestEnvironment.
const (
	CardRuleRequestEnvironmentDevelopment CardRuleRequestEnvironment = "development"

	CardRuleRequestEnvironmentProduction CardRuleRequestEnvironment = "production"

	CardRuleRequestEnvironmentStaging CardRuleRequestEnvironment = "staging"
)

// Defines values for CardRuleRequestInvalidRuleFallbackStrategy.
const (
	CardRuleRequestInvalidRuleFallbackStrategyDecline CardRuleRequestInvalidRuleFallbackStrategy = "decline"

	CardRuleRequestInvalidRuleFallbackStrategySkip CardRuleRequestInvalidRuleFallbackStrategy = "skip"

	CardRuleRequestInvalidRuleFallbackStrategyUseAllProviders CardRuleRequestInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleRequestUnprocessableFallbackStrategy.
const (
	CardRuleRequestUnprocessableFallbackStrategyDecline CardRuleRequestUnprocessableFallbackStrategy = "decline"

	CardRuleRequestUnprocessableFallbackStrategyUseAllProviders CardRuleRequestUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleTextConditionKey.
const (
	CardRuleTextConditionKeyCurrency CardRuleTextConditionKey = "currency"

	CardRuleTextConditionKeyScheme CardRuleTextConditionKey = "scheme"
)

// Defines values for CardRuleTextConditionMatch.
const (
	CardRuleTextConditionMatchText CardRuleTextConditionMatch = "text"
)

// Defines values for CardRuleTextConditionOperator.
const (
	CardRuleTextConditionOperatorIN CardRuleTextConditionOperator = "IN"

	CardRuleTextConditionOperatorNOTIN CardRuleTextConditionOperator = "NOT IN"
)

// Defines values for CardRuleUpdateEnvironment.
const (
	CardRuleUpdateEnvironmentDevelopment CardRuleUpdateEnvironment = "development"

	CardRuleUpdateEnvironmentProduction CardRuleUpdateEnvironment = "production"

	CardRuleUpdateEnvironmentStaging CardRuleUpdateEnvironment = "staging"
)

// Defines values for CardRuleUpdateInvalidRuleFallbackStrategy.
const (
	CardRuleUpdateInvalidRuleFallbackStrategyDecline CardRuleUpdateInvalidRuleFallbackStrategy = "decline"

	CardRuleUpdateInvalidRuleFallbackStrategySkip CardRuleUpdateInvalidRuleFallbackStrategy = "skip"

	CardRuleUpdateInvalidRuleFallbackStrategyUseAllProviders CardRuleUpdateInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleUpdateUnprocessableFallbackStrategy.
const (
	CardRuleUpdateUnprocessableFallbackStrategyDecline CardRuleUpdateUnprocessableFallbackStrategy = "decline"

	CardRuleUpdateUnprocessableFallbackStrategyUseAllProviders CardRuleUpdateUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for Error400BadRequestCode.
const (
	Error400BadRequestCodeBadRequest Error400BadRequestCode = "bad_request"
)

// Defines values for Error400BadRequestStatus.
const (
	Error400BadRequestStatusN00 Error400BadRequestStatus = 400
)

// Defines values for Error400BadRequestType.
const (
	Error400BadRequestTypeError Error400BadRequestType = "error"
)

// Defines values for Error400IncorrectJsonCode.
const (
	Error400IncorrectJsonCodeIncorrectJson Error400IncorrectJsonCode = "incorrect_json"
)

// Defines values for Error400IncorrectJsonStatus.
const (
	Error400IncorrectJsonStatusN00 Error400IncorrectJsonStatus = 400
)

// Defines values for Error400IncorrectJsonType.
const (
	Error400IncorrectJsonTypeError Error400IncorrectJsonType = "error"
)

// Defines values for Error401UnauthorizedCode.
const (
	Error401UnauthorizedCodeUnauthorized Error401UnauthorizedCode = "unauthorized"
)

// Defines values for Error401UnauthorizedMessage.
const (
	Error401UnauthorizedMessageNoValidAPIAuthenticationFound Error401UnauthorizedMessage = "No valid API authentication found"
)

// Defines values for Error401UnauthorizedStatus.
const (
	Error401UnauthorizedStatusN01 Error401UnauthorizedStatus = 401
)

// Defines values for Error401UnauthorizedType.
const (
	Error401UnauthorizedTypeError Error401UnauthorizedType = "error"
)

// Defines values for Error404NotFoundCode.
const (
	Error404NotFoundCodeNotFound Error404NotFoundCode = "not_found"
)

// Defines values for Error404NotFoundMessage.
const (
	Error404NotFoundMessageTheResourceCouldNotBeFound Error404NotFoundMessage = "The resource could not be found"
)

// Defines values for Error404NotFoundStatus.
const (
	Error404NotFoundStatusN04 Error404NotFoundStatus = 404
)

// Defines values for Error404NotFoundType.
const (
	Error404NotFoundTypeError Error404NotFoundType = "error"
)

// Defines values for Error404PendingCreationCode.
const (
	Error404PendingCreationCodePendingCreation Error404PendingCreationCode = "pending_creation"
)

// Defines values for Error404PendingCreationMessage.
const (
	Error404PendingCreationMessageTheResourceIsStillPending Error404PendingCreationMessage = "The resource is still pending"
)

// Defines values for Error404PendingCreationStatus.
const (
	Error404PendingCreationStatusN04 Error404PendingCreationStatus = 404
)

// Defines values for Error404PendingCreationType.
const (
	Error404PendingCreationTypeError Error404PendingCreationType = "error"
)

// Defines values for Error409DuplicateRecordCode.
const (
	Error409DuplicateRecordCodeDuplicateRecord Error409DuplicateRecordCode = "duplicate_record"
)

// Defines values for Error409DuplicateRecordStatus.
const (
	Error409DuplicateRecordStatusN09 Error409DuplicateRecordStatus = 409
)

// Defines values for Error409DuplicateRecordType.
const (
	Error409DuplicateRecordTypeError Error409DuplicateRecordType = "error"
)

// Defines values for ErrorDetailLocation.
const (
	ErrorDetailLocationBody ErrorDetailLocation = "body"

	ErrorDetailLocationHeader ErrorDetailLocation = "header"

	ErrorDetailLocationPath ErrorDetailLocation = "path"

	ErrorDetailLocationQuery ErrorDetailLocation = "query"
)

// Defines values for ErrorGenericType.
const (
	ErrorGenericTypeError ErrorGenericType = "error"
)

// Defines values for MerchantType.
const (
	MerchantTypeMerchant MerchantType = "merchant"
)

// Defines values for PayPalEnvironment.
const (
	PayPalEnvironmentDevelopment PayPalEnvironment = "development"

	PayPalEnvironmentProduction PayPalEnvironment = "production"

	PayPalEnvironmentStaging PayPalEnvironment = "staging"
)

// Defines values for PayPalMethod.
const (
	PayPalMethodPaypal PayPalMethod = "paypal"
)

// Defines values for PayPalStatus.
const (
	PayPalStatusBuyerApprovalDeclined PayPalStatus = "buyer_approval_declined"

	PayPalStatusBuyerApprovalPending PayPalStatus = "buyer_approval_pending"

	PayPalStatusBuyerApprovalTimedout PayPalStatus = "buyer_approval_timedout"

	PayPalStatusBuyerApproved PayPalStatus = "buyer_approved"

	PayPalStatusProcessing PayPalStatus = "processing"

	PayPalStatusProcessingFailed PayPalStatus = "processing_failed"

	PayPalStatusStored PayPalStatus = "stored"

	PayPalStatusUsed PayPalStatus = "used"
)

// Defines values for PayPalType.
const (
	PayPalTypePaymentMethod PayPalType = "payment-method"
)

// Defines values for PayPalRequestMethod.
const (
	PayPalRequestMethodPaypal PayPalRequestMethod = "paypal"
)

// Defines values for PaymentOptionMethod.
const (
	PaymentOptionMethodCard PaymentOptionMethod = "card"

	PaymentOptionMethodPaypal PaymentOptionMethod = "paypal"
)

// Defines values for PaymentOptionType.
const (
	PaymentOptionTypePaymentOption PaymentOptionType = "payment-option"
)

// Defines values for PaymentServiceCredentialsMode.
const (
	PaymentServiceCredentialsModeLive PaymentServiceCredentialsMode = "live"

	PaymentServiceCredentialsModeSandbox PaymentServiceCredentialsMode = "sandbox"
)

// Defines values for PaymentServiceEnvironments.
const (
	PaymentServiceEnvironmentsDevelopment PaymentServiceEnvironments = "development"

	PaymentServiceEnvironmentsProduction PaymentServiceEnvironments = "production"

	PaymentServiceEnvironmentsStaging PaymentServiceEnvironments = "staging"
)

// Defines values for PaymentServiceMethod.
const (
	PaymentServiceMethodCard PaymentServiceMethod = "card"

	PaymentServiceMethodPaypal PaymentServiceMethod = "paypal"
)

// Defines values for PaymentServiceStatus.
const (
	PaymentServiceStatusCreated PaymentServiceStatus = "created"

	PaymentServiceStatusFailed PaymentServiceStatus = "failed"

	PaymentServiceStatusPending PaymentServiceStatus = "pending"
)

// Defines values for PaymentServiceType.
const (
	PaymentServiceTypePaymentService PaymentServiceType = "payment-service"
)

// Defines values for PaymentServiceDefinitionMethod.
const (
	PaymentServiceDefinitionMethodCard PaymentServiceDefinitionMethod = "card"

	PaymentServiceDefinitionMethodPaypal PaymentServiceDefinitionMethod = "paypal"
)

// Defines values for PaymentServiceUpdateCredentialsMode.
const (
	PaymentServiceUpdateCredentialsModeLive PaymentServiceUpdateCredentialsMode = "live"

	PaymentServiceUpdateCredentialsModeSandbox PaymentServiceUpdateCredentialsMode = "sandbox"
)

// Defines values for PaymentServiceUpdateEnvironments.
const (
	PaymentServiceUpdateEnvironmentsDevelopment PaymentServiceUpdateEnvironments = "development"

	PaymentServiceUpdateEnvironmentsProduction PaymentServiceUpdateEnvironments = "production"

	PaymentServiceUpdateEnvironmentsStaging PaymentServiceUpdateEnvironments = "staging"
)

// Defines values for SessionTokenType.
const (
	SessionTokenTypeBearer SessionTokenType = "bearer"
)

// Defines values for SessionType.
const (
	SessionTypeAuthSession SessionType = "auth.session"
)

// Defines values for StatusResourceType.
const (
	StatusResourceTypePaymentMethod StatusResourceType = "payment-method"

	StatusResourceTypeTransaction StatusResourceType = "transaction"
)

// Defines values for StatusStatus.
const (
	StatusStatusPending StatusStatus = "pending"
)

// Defines values for StatusType.
const (
	StatusTypeStatus StatusType = "status"
)

// Defines values for TokenizedRequestMethod.
const (
	TokenizedRequestMethodId TokenizedRequestMethod = "id"
)

// Defines values for TransactionEnvironment.
const (
	TransactionEnvironmentDevelopment TransactionEnvironment = "development"

	TransactionEnvironmentProduction TransactionEnvironment = "production"

	TransactionEnvironmentStaging TransactionEnvironment = "staging"
)

// Defines values for TransactionStatus.
const (
	TransactionStatusAuthorizationDeclined TransactionStatus = "authorization_declined"

	TransactionStatusAuthorizationExpired TransactionStatus = "authorization_expired"

	TransactionStatusAuthorizationPending TransactionStatus = "authorization_pending"

	TransactionStatusAuthorizationVoided TransactionStatus = "authorization_voided"

	TransactionStatusAuthorized TransactionStatus = "authorized"

	TransactionStatusBuyerApprovalDeclined TransactionStatus = "buyer_approval_declined"

	TransactionStatusBuyerApprovalPending TransactionStatus = "buyer_approval_pending"

	TransactionStatusBuyerApprovalTimedout TransactionStatus = "buyer_approval_timedout"

	TransactionStatusBuyerApproved TransactionStatus = "buyer_approved"

	TransactionStatusCaptureDeclined TransactionStatus = "capture_declined"

	TransactionStatusCapturePending TransactionStatus = "capture_pending"

	TransactionStatusCaptured TransactionStatus = "captured"

	TransactionStatusProcessing TransactionStatus = "processing"

	TransactionStatusProcessingFailed TransactionStatus = "processing_failed"

	TransactionStatusRefunded TransactionStatus = "refunded"
)

// Defines values for TransactionType.
const (
	TransactionTypeTransaction TransactionType = "transaction"
)

// Defines values for TransactionRequestEnvironment.
const (
	TransactionRequestEnvironmentDevelopment TransactionRequestEnvironment = "development"

	TransactionRequestEnvironmentProduction TransactionRequestEnvironment = "production"

	TransactionRequestEnvironmentStaging TransactionRequestEnvironment = "staging"
)

// Defines values for TransactionRequestIntent.
const (
	TransactionRequestIntentApprove TransactionRequestIntent = "approve"

	TransactionRequestIntentAuthorize TransactionRequestIntent = "authorize"

	TransactionRequestIntentCapture TransactionRequestIntent = "capture"
)

// Defines values for UserType.
const (
	UserTypeUser UserType = "user"
)

// Details about an API key pair.
type APIKeyPair struct {

	// The date and time when this key pair was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A unique ID for this key-pair. This ID is the thumbprint of the key.
	Id *string `json:"id,omitempty"`

	// The private key for the key-pair. This is only returned after
	// the key is initially requested. For subsequent API calls this value is
	// `null`.
	PrivateKey *string `json:"private_key"`

	// `api-key-pair`.
	Type *APIKeyPairType `json:"type,omitempty"`

	// The date and time when this key pair was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// `api-key-pair`.
type APIKeyPairType string

// A list of the currently active API key pairs.
type APIKeyPairs struct {
	Items *[]APIKeyPair `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// Buyer defines model for Buyer.
type Buyer struct {

	// The date and time
	// when this buyer was created in our system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
	DisplayName *string `json:"display_name"`

	// An external identifier that can be used to match the buyer against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique Gr4vy ID for this buyer.
	Id *string `json:"id,omitempty"`

	// The type of this resource. Is always `buyer`.
	Type *BuyerType `json:"type,omitempty"`

	// The date and time
	// when this buyer was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The type of this resource. Is always `buyer`.
type BuyerType string

// A request to create a buyer.
type BuyerRequest struct {

	// A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
	DisplayName *string `json:"display_name"`

	// An external identifier that can be used to match the buyer against your own records. This value needs to be unique for all buyers.
	ExternalIdentifier *string `json:"external_identifier"`
}

// BuyerUpdate defines model for BuyerUpdate.
type BuyerUpdate struct {
	// Embedded struct due to allOf(#/components/schemas/BuyerRequest)
	BuyerRequest `yaml:",inline"`
}

// A list of buyers.
type Buyers struct {

	// A list of buyers.
	Items *[]Buyer `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A stored card.
type Card struct {

	// The optional buyer for which this payment method has been stored.
	Buyer *struct {
		// Embedded struct due to allOf(#/components/schemas/Buyer)
		Buyer `yaml:",inline"`
	} `json:"buyer"`

	// The date and time when this payment method was first created in our
	// system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Additional details about a stored card.
	Details *CardDetails `json:"details,omitempty"`

	// The environment this payment method has been stored for. This will be null
	// of the payment method was not stored.
	Environment *CardEnvironment `json:"environment"`

	// An external identifier that can be used to match the payment method
	// against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// `card`.
	Method *CardMethod `json:"method,omitempty"`

	// The state of the card tokenization.
	Status *CardStatus `json:"status,omitempty"`

	// `payment-method`.
	Type *CardType `json:"type,omitempty"`

	// The date and time when this payment method was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment this payment method has been stored for. This will be null
// of the payment method was not stored.
type CardEnvironment string

// `card`.
type CardMethod string

// The state of the card tokenization.
type CardStatus string

// `payment-method`.
type CardType string

// A mini format version of the card.
type CardTokenized struct {

	// Additional details about a stored card.
	Details *CardDetails `json:"details,omitempty"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// `card`.
	Method *CardTokenizedMethod `json:"method,omitempty"`

	// `payment-method`.
	Type *CardTokenizedType `json:"type,omitempty"`
}

// `card`.
type CardTokenizedMethod string

// `payment-method`.
type CardTokenizedType string

// Additional details about a stored card.
type CardDetails struct {

	// The expiration date for a card.
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// The type of the card.
	Scheme *CardDetailsScheme `json:"scheme,omitempty"`

	// The last 4 digits of the card number.
	Suffix *string `json:"suffix,omitempty"`
}

// The type of the card.
type CardDetailsScheme string

// Card details to use in a transaction or to register a new payment method.
type CardRequest struct {

	// The `external_identifier` of the buyer to associate this payment method
	// to. If this field is provided then the `buyer_id` field
	// needs to be unset.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// The ID of the buyer to associate this payment method to. If this field is
	// provided then the `buyer_external_identifier` field needs to be unset.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Defines the environment to store this card for. Setting this to
	// anything other than `production` will force Gr4vy to use the payment
	// services configured for that environment.
	Environment *CardRequestEnvironment `json:"environment,omitempty"`

	// The expiration date of the card, formatted `MM/YY`.
	ExpirationDate string `json:"expiration_date"`

	// An external identifier that can be used to match the card against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// `card`.
	Method CardRequestMethod `json:"method"`

	// The 15-16 digit number for this card as it can be found on the
	// front of the card.
	Number string `json:"number"`

	// The 3 or 4 digit security code often found on the card. This often
	// referred to as the CVV or CVD.
	SecurityCode string `json:"security_code"`
}

// Defines the environment to store this card for. Setting this to
// anything other than `production` will force Gr4vy to use the payment
// services configured for that environment.
type CardRequestEnvironment string

// `card`.
type CardRequestMethod string

// A card rule that defines a custom payment provider to use for a card
// transaction. Multiple rules can exists at any time and they are processed by
// priority.
type CardRule struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions *[]interface{} `json:"conditions,omitempty"`

	// The date and time when this rule was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleEnvironment `json:"environment,omitempty"`

	// The ID of the rule.
	Id *string `json:"id,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds *[]string `json:"payment_service_ids,omitempty"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first.
	Position *float32 `json:"position,omitempty"`

	// `card-rule`.
	Type *CardRuleType `json:"type,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`

	// The date and time when this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleInvalidRuleFallbackStrategy string

// `card-rule`.
type CardRuleType string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleUnprocessableFallbackStrategy string

// Part of a rule that matches numeric fields. It defines the condition under
// which this rule applies.
type CardRuleNumberCondition struct {

	// The transaction field to filter by.
	Key CardRuleNumberConditionKey `json:"key"`

	// `number`.
	Match CardRuleNumberConditionMatch `json:"match"`

	// The comparison to make to `value` property.
	Operator string `json:"operator"`

	// The values to compare the `key` to.
	Value float32 `json:"value"`
}

// The transaction field to filter by.
type CardRuleNumberConditionKey string

// `number`.
type CardRuleNumberConditionMatch string

// Creates a new rule for a card transactions.
type CardRuleRequest struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions []interface{} `json:"conditions"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleRequestEnvironment `json:"environment,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleRequestInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds []string `json:"payment_service_ids"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first. When a rule is inserted at a position, any rules with
	// the the same value or higher are down a position accordingly. When left
	// out, the rule is inserted at the end of the list.
	Position *float32 `json:"position,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleRequestUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleRequestEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleRequestInvalidRuleFallbackStrategy string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleRequestUnprocessableFallbackStrategy string

// Part of a rule that matches text fields. It defines the condition under
// which this rule applies.
type CardRuleTextCondition struct {

	// The transaction field to filter by.
	Key CardRuleTextConditionKey `json:"key"`

	// `text`.
	Match CardRuleTextConditionMatch `json:"match"`

	// The comparison to make to `value` property.
	Operator CardRuleTextConditionOperator `json:"operator"`

	// The values to compare the `key` to.
	Values []string `json:"values"`
}

// The transaction field to filter by.
type CardRuleTextConditionKey string

// `text`.
type CardRuleTextConditionMatch string

// The comparison to make to `value` property.
type CardRuleTextConditionOperator string

// Updates a rule for a card transactions.
type CardRuleUpdate struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions *[]interface{} `json:"conditions,omitempty"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleUpdateEnvironment `json:"environment,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleUpdateInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds *[]string `json:"payment_service_ids,omitempty"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first. When a rule is inserted at a position, any rules with
	// the the same value or higher are down a position accordingly.
	Position *float32 `json:"position,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleUpdateUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleUpdateEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleUpdateInvalidRuleFallbackStrategy string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleUpdateUnprocessableFallbackStrategy string

// A list of card rules.
type CardRules struct {

	// A list of card rules.
	Items *[]CardRule `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// Bad Request (HTTP 400).
type Error400BadRequest struct {

	// `bad_request`.
	Code *Error400BadRequestCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Describes the fields that are missing or incorrectly formatted in the API
	// request.
	Message *string `json:"message,omitempty"`

	// `400`.
	Status *Error400BadRequestStatus `json:"status,omitempty"`

	// `error`.
	Type *Error400BadRequestType `json:"type,omitempty"`
}

// `bad_request`.
type Error400BadRequestCode string

// `400`.
type Error400BadRequestStatus int

// `error`.
type Error400BadRequestType string

// Incorrect JSON (HTTP 400).
type Error400IncorrectJson struct {

	// `incorrect_json`.
	Code *Error400IncorrectJsonCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Incorrect JSON. The request body could not be parsed as valid JSON.
	Message *string `json:"message,omitempty"`

	// `400`.
	Status *Error400IncorrectJsonStatus `json:"status,omitempty"`

	// `error`.
	Type *Error400IncorrectJsonType `json:"type,omitempty"`
}

// `incorrect_json`.
type Error400IncorrectJsonCode string

// `400`.
type Error400IncorrectJsonStatus int

// `error`.
type Error400IncorrectJsonType string

// Unauthorized Error (HTTP 401).
type Error401Unauthorized struct {

	// `unauthorized`.
	Code *Error401UnauthorizedCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// No valid API authentication found.
	Message *Error401UnauthorizedMessage `json:"message,omitempty"`

	// `401`.
	Status *Error401UnauthorizedStatus `json:"status,omitempty"`

	// `error`.
	Type *Error401UnauthorizedType `json:"type,omitempty"`
}

// `unauthorized`.
type Error401UnauthorizedCode string

// No valid API authentication found.
type Error401UnauthorizedMessage string

// `401`.
type Error401UnauthorizedStatus int

// `error`.
type Error401UnauthorizedType string

// Not Found Error (HTTP 404).
type Error404NotFound struct {

	// `not_found`.
	Code *Error404NotFoundCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// The resource could not be found.
	Message *Error404NotFoundMessage `json:"message,omitempty"`

	// `404`.
	Status *Error404NotFoundStatus `json:"status,omitempty"`

	// `error`.
	Type *Error404NotFoundType `json:"type,omitempty"`
}

// `not_found`.
type Error404NotFoundCode string

// The resource could not be found.
type Error404NotFoundMessage string

// `404`.
type Error404NotFoundStatus int

// `error`.
type Error404NotFoundType string

// Pending Creation Error (HTTP 404).
type Error404PendingCreation struct {

	// `pending_creation`.
	Code *Error404PendingCreationCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// The resource is still pending.
	Message *Error404PendingCreationMessage `json:"message,omitempty"`

	// `404`.
	Status *Error404PendingCreationStatus `json:"status,omitempty"`

	// `error`.
	Type *Error404PendingCreationType `json:"type,omitempty"`
}

// `pending_creation`.
type Error404PendingCreationCode string

// The resource is still pending.
type Error404PendingCreationMessage string

// `404`.
type Error404PendingCreationStatus int

// `error`.
type Error404PendingCreationType string

// Duplicate Record Error (HTTP 409).
type Error409DuplicateRecord struct {

	// `duplicate_record`.
	Code *Error409DuplicateRecordCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Further details on the field that triggered the error.
	Message *string `json:"message,omitempty"`

	// `409`.
	Status *Error409DuplicateRecordStatus `json:"status,omitempty"`

	// `error`.
	Type *Error409DuplicateRecordType `json:"type,omitempty"`
}

// `duplicate_record`.
type Error409DuplicateRecordCode string

// `409`.
type Error409DuplicateRecordStatus int

// `error`.
type Error409DuplicateRecordType string

// Additional detail about the part of a request body that caused an issue.
type ErrorDetail struct {

	// The location where the error caused an issue.
	Location *ErrorDetailLocation `json:"location,omitempty"`

	// A human readable message for this error detail.
	Message *string `json:"message,omitempty"`

	// The exact item for which the validation did not succeed. This is a JSON
	// pointer for request bodies, while for query, path, and header parameters
	// it is the name of the parameter.
	Pointer *string `json:"pointer,omitempty"`

	// A unique identifier for the type of error that occurred.
	Type *string `json:"type,omitempty"`
}

// The location where the error caused an issue.
type ErrorDetailLocation string

// A generic client error.
type ErrorGeneric struct {

	// A custom code to further describe the type of error being returned. This code provides further specification within the HTTP `status` code and can be used by a program to define logic based on the error.
	Code *string `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// A human readable message that describes the error. The content of this field should not be used to determine any business logic.
	Message *string `json:"message,omitempty"`

	// The HTTP status code of this error.
	Status *int32 `json:"status,omitempty"`

	// The type of this object. This is always `error`.
	Type *ErrorGenericType `json:"type,omitempty"`
}

// The type of this object. This is always `error`.
type ErrorGenericType string

// A merchant.
type Merchant struct {

	// The name of this merchant as it will be displayed in the admin UI.
	DisplayName *string `json:"display_name,omitempty"`

	// The unique short-name of the merchant.
	Id *string `json:"id,omitempty"`

	// `merchant`.
	Type *MerchantType `json:"type,omitempty"`
}

// `merchant`.
type MerchantType string

// A stored PayPal account.
type PayPal struct {

	// The optional buyer for which this payment method has been stored.
	Buyer *struct {
		// Embedded struct due to allOf(#/components/schemas/Buyer)
		Buyer `yaml:",inline"`
	} `json:"buyer"`

	// The date and time when this payment method was first created in our
	// system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Additional details about a stored PayPal account.
	Details *PayPalDetails `json:"details,omitempty"`

	// The environment this payment method has been stored for. This will be null
	// of the payment method was not stored.
	Environment *PayPalEnvironment `json:"environment"`

	// An external identifier that can be used to match the payment method
	// against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// `paypal`.
	Method *PayPalMethod `json:"method,omitempty"`

	// The state of the account tokenization. After the first call this will
	// be set to `buyer_approval_pending` and the response will include
	// an `approval_url`. The buyer needs to be redirected to this URL
	// to authorize the future payments.
	Status *PayPalStatus `json:"status,omitempty"`

	// `payment-method`.
	Type *PayPalType `json:"type,omitempty"`

	// The date and time when this payment method was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment this payment method has been stored for. This will be null
// of the payment method was not stored.
type PayPalEnvironment string

// `paypal`.
type PayPalMethod string

// The state of the account tokenization. After the first call this will
// be set to `buyer_approval_pending` and the response will include
// an `approval_url`. The buyer needs to be redirected to this URL
// to authorize the future payments.
type PayPalStatus string

// `payment-method`.
type PayPalType string

// Additional details about a stored PayPal account.
type PayPalDetails struct {

	// The optional URL that the buyer needs to be redirected to to further authorize their PayPal payments.
	ApprovalUrl *string `json:"approval_url"`

	// The email address associated to the PayPal account.
	EmailAddress *string `json:"email_address"`
}

// PayPal request to use in a transaction or to register a new payment method.
type PayPalRequest struct {

	// The `external_identifier` of the buyer to associate this payment method
	// to. If this field is provided then the `buyer_id` field
	// needs to be unset.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// The ID of the buyer to associate this payment method to. If this field is
	// provided then the `buyer_external_identifier` field needs to be unset.
	BuyerId *string `json:"buyer_id,omitempty"`

	// An external identifier that can be used to match the account against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// `paypal`.
	Method PayPalRequestMethod `json:"method"`

	// The redirect URL to redirect a buyer to after they have authorized their
	// PayPal transaction.
	RedirectUrl string `json:"redirect_url"`
}

// `paypal`.
type PayPalRequestMethod string

// A list of stored payment methods.
type PaymentMethods struct {

	// A list of stored payment methods.
	Items *[]Card `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A list of stored payment methods in token format.
type PaymentMethodsTokenized struct {

	// A list of stored payment methods in token format.
	Items *[]CardTokenized `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// An available payment option for a locale.
type PaymentOption struct {

	// The type of payment method that is available.
	Method *PaymentOptionMethod `json:"method,omitempty"`

	// `payment-option`.
	Type *PaymentOptionType `json:"type,omitempty"`
}

// The type of payment method that is available.
type PaymentOptionMethod string

// `payment-option`.
type PaymentOptionType string

// A list of payment options.
type PaymentOptions struct {
	Items *[]PaymentOption `json:"items,omitempty"`
}

// An active, configured payment service.
type PaymentService struct {

	// A list of countries for which this service is enabled, in ISO two-letter
	// code format.
	AcceptedCountries *[]string `json:"accepted_countries,omitempty"`

	// A list of currencies for which this service is enabled, in ISO 4217
	// three-letter code format.
	AcceptedCurrencies *[]string `json:"accepted_currencies,omitempty"`

	// Defines if this service is currently active or not.
	Active *bool `json:"active,omitempty"`

	// The date and time when this service was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Defines if the credentials are intended for the service's live API or
	// sandbox/test API.
	CredentialsMode *PaymentServiceCredentialsMode `json:"credentials_mode,omitempty"`

	// The custom name set for this service.
	DisplayName *string `json:"display_name,omitempty"`

	// Determines the Gr4vy environments in which this service should be
	// available. This can be used in combination with the `environment`
	// parameters in the payment method and transaction APIs to route
	// transactions through this service.
	Environments *[]PaymentServiceEnvironments `json:"environments,omitempty"`

	// The ID of this payment service.
	Id *string `json:"id,omitempty"`

	// Defines the ID of the payment method that this service handles.
	Method *PaymentServiceMethod `json:"method,omitempty"`

	// The ID of the payment service definition used to create this service.
	PaymentServiceDefinitionId *string `json:"payment_service_definition_id,omitempty"`

	// The numeric rank of a payment service. Payment services with a lower
	// position value are processed first.
	Position *float32 `json:"position,omitempty"`

	// The current status of this service. This will start off as pending, move
	// to created, and might eventually move to an error status if and when the
	// credentials are no longer valid.
	Status *PaymentServiceStatus `json:"status,omitempty"`

	// The type of this resource.
	Type *PaymentServiceType `json:"type,omitempty"`

	// The date and time when this service was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Defines if the credentials are intended for the service's live API or
// sandbox/test API.
type PaymentServiceCredentialsMode string

// PaymentServiceEnvironments defines model for PaymentService.Environments.
type PaymentServiceEnvironments string

// Defines the ID of the payment method that this service handles.
type PaymentServiceMethod string

// The current status of this service. This will start off as pending, move
// to created, and might eventually move to an error status if and when the
// credentials are no longer valid.
type PaymentServiceStatus string

// The type of this resource.
type PaymentServiceType string

// An available payment service that can be configured.
type PaymentServiceDefinition struct {

	// The display name of this service.
	DisplayName *string `json:"display_name,omitempty"`

	// A list of fields that need to be submitted when activating the payment. service.
	Fields *[]struct {

		// The name to display for a field in the dashboard.
		DisplayName *string `json:"display_name,omitempty"`

		// Defines the type of input that needs to be rendered for this field.
		Format *string `json:"format,omitempty"`

		// The key of a field that needs to be submitted.
		Key *string `json:"key,omitempty"`

		// Defines if this field is required when the service is created.
		Required *bool `json:"required,omitempty"`
	} `json:"fields,omitempty"`

	// The ID of the payment service. This is the underlying provider followed by a dash followed by the payment method ID.
	Id *string `json:"id,omitempty"`

	// The ID of the payment method that this services handles.
	Method *PaymentServiceDefinitionMethod `json:"method,omitempty"`

	// A list of two-letter ISO country codes that this service supports.
	SupportedCountries *[]string `json:"supported_countries,omitempty"`

	// A list of three-letter ISO currency codes that this service supports.
	SupportedCurrencies *[]string `json:"supported_currencies,omitempty"`

	// `payment-service-definition`.
	Type *string `json:"type,omitempty"`
}

// The ID of the payment method that this services handles.
type PaymentServiceDefinitionMethod string

// A list of available payment services definitions.
type PaymentServiceDefinitions struct {
	Items *[]PaymentServiceDefinition `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// PaymentServiceRequest defines model for PaymentServiceRequest.
type PaymentServiceRequest struct {
	// Embedded struct due to allOf(#/components/schemas/PaymentServiceUpdate)
	PaymentServiceUpdate `yaml:",inline"`
	// Embedded fields due to inline allOf schema

	// The ID of the payment service to use.
	PaymentServiceDefinitionId *string `json:"payment_service_definition_id,omitempty"`
}

// Request body for updating an active payment service.
type PaymentServiceUpdate struct {

	// A list of countries that this payment service needs to support in ISO two-letter code format.
	AcceptedCountries *[]string `json:"accepted_countries,omitempty"`

	// A list of currencies that this payment service needs to support in ISO 4217 three-letter code format.
	AcceptedCurrencies *[]string `json:"accepted_currencies,omitempty"`

	// Defines if this service is currently active or not.
	Active *bool `json:"active,omitempty"`

	// Defines if the credentials are intended for the service's live API or
	// sandbox/test API.
	CredentialsMode *PaymentServiceUpdateCredentialsMode `json:"credentials_mode,omitempty"`

	// A custom name for the payment service. This will be shown in the Admin UI.
	DisplayName *string `json:"display_name,omitempty"`

	// Determines the Gr4vy environments in which this service should be
	// available. This can be used in combination with the `environment`
	// parameters in the payment method and transaction APIs to route
	// transactions through this service.
	Environments *[]PaymentServiceUpdateEnvironments `json:"environments,omitempty"`

	// A list of fields, each containing a key-value pair for each field defined by the definition for this payment service.
	Fields *[]struct {

		// The key of the field to set a value for.
		Key string `json:"key"`

		// The value of a field to set.
		Value string `json:"value"`
	} `json:"fields,omitempty"`

	// The numeric rank of a payment service. Payment services with a lower
	// position value are processed first. When a payment services is inserted at
	// a position, any payment services with the the same value or higher are
	// shifted down a position accordingly. When left out, the payment service is
	// inserted at the end of the list.
	Position *float32 `json:"position,omitempty"`
}

// Defines if the credentials are intended for the service's live API or
// sandbox/test API.
type PaymentServiceUpdateCredentialsMode string

// PaymentServiceUpdateEnvironments defines model for PaymentServiceUpdate.Environments.
type PaymentServiceUpdateEnvironments string

// A list of active, configured payment services.
type PaymentServices struct {
	Items *[]PaymentService `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A user session.
type Session struct {

	// A server-signed JWT that can be used as the bearer token in any
	// API calls.
	AccessToken *string `json:"access_token,omitempty"`

	// The time in seconds in seconds by which the `access_token` token will
	// expire.
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// A server-signed JWT that can be used as the bearer token to refresh the
	// access token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// `bearer`.
	TokenType *SessionTokenType `json:"token_type,omitempty"`

	// `auth.session`.
	Type *SessionType `json:"type,omitempty"`
}

// `bearer`.
type SessionTokenType string

// `auth.session`.
type SessionType string

// A request to create a session using an email address and password.
type SessionRequest struct {

	// The email address of the user to log in as.
	EmailAddress string `json:"email_address"`

	// The password the user to log in as.
	Password string `json:"password"`
}

// In many cases the Gr4vy API returns asynchronously, kicking off a job to
// create an authorization or a transaction, and returning a `Status` object with
// the ID of the pending object. The ID of this resource can be used to query an
// objects status, or additionally the client can use Pub/Sub to subscribe to the
// creation of the pending object.
type Status struct {

	// An external identifier that can be used to match the record against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The ID of the object for which this status has been created.
	ResourceId *string `json:"resource_id,omitempty"`

	// The type of the object that is pending.
	ResourceType *StatusResourceType `json:"resource_type,omitempty"`

	// The status of this resource being created. This is always `pending`.
	Status *StatusStatus `json:"status,omitempty"`

	// The type of this object. This is always `status`.
	Type *StatusType `json:"type,omitempty"`
}

// The type of the object that is pending.
type StatusResourceType string

// The status of this resource being created. This is always `pending`.
type StatusStatus string

// The type of this object. This is always `status`.
type StatusType string

// A list of status resources.
type Statuses struct {

	// A list of authorizations.
	Items *[]Status `json:"items,omitempty"`
}

// Details for a previously tokenized payment method.
type TokenizedRequest struct {

	// A ID that represents a previously tokenized payment method.
	// This token can represent any type of payment method.
	Id string `json:"id"`

	// `id`.
	Method TokenizedRequestMethod `json:"method"`
}

// `id`.
type TokenizedRequestMethod string

// A transaction record.
type Transaction struct {

	// The currency amount captured by this transaction.
	Amount *float32 `json:"amount,omitempty"`

	// The date and time when this transaction was created in our system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The currency code for this transaction.
	Currency *string `json:"currency,omitempty"`

	// The environment this transaction has been created in.
	Environment *TransactionEnvironment `json:"environment,omitempty"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique identifier for this transaction.
	Id            *string      `json:"id,omitempty"`
	PaymentMethod *interface{} `json:"payment_method,omitempty"`

	// An active, configured payment service.
	PaymentService *PaymentService `json:"payment_service,omitempty"`

	// The status of the transaction being processed. This is different from the
	// `status` field in that it represents the status of the transaction at the
	// payment processor, not the status of the transaction created in Gr4vy.
	Status *TransactionStatus `json:"status,omitempty"`

	// The type of this resource. Is always `transaction`.
	Type *TransactionType `json:"type,omitempty"`

	// Defines when the transaction was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment this transaction has been created in.
type TransactionEnvironment string

// The status of the transaction being processed. This is different from the
// `status` field in that it represents the status of the transaction at the
// payment processor, not the status of the transaction created in Gr4vy.
type TransactionStatus string

// The type of this resource. Is always `transaction`.
type TransactionType string

// A request to capture a transaction.
type TransactionCaptureRequest struct {

	// The (partial) amount to capture.
	//
	// When left blank, this will capture the entire amount.
	Amount float32 `json:"amount"`

	// A supported ISO-4217 currency code.
	Currency string `json:"currency"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier,omitempty"`
}

// A request to create a transaction.
type TransactionRequest struct {

	// The monetary amount to create an authorization for, in the smallest
	// currency unit for the given currency, for example `1299` cents to create
	// an authorization for `$12.99`.
	//
	// For BitCoin, this value will be a decimal point number, for example
	// `0.0039`.
	Amount float32 `json:"amount"`

	// A supported ISO-4217 currency code.
	Currency string `json:"currency"`

	// Defines the environment to create this transaction in. Setting this to
	// anything other than `production` will force Gr4vy to use the payment
	// a service configured for that environment.
	Environment *TransactionRequestEnvironment `json:"environment,omitempty"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// Defines the intent of this API call. This determines the desired initial
	// state of the transaction.
	//
	// * `approve` - Captures approval for the transaction from the user but does
	// not authorize it. This is only available to payment methods that require
	// explicit approval, like PayPal.
	// * `authorize` - (Default) Optionally approves and then authorizes a
	// transaction but does not capture the funds.
	// * `capture` - Optionally approves and then authorizes and captures the
	// funds of the transaction.
	Intent *TransactionRequestIntent `json:"intent,omitempty"`

	// The optional payment method details to create an authorization for. This field is required for processing a card.
	PaymentMethod interface{} `json:"payment_method"`

	// Whether or not to also try and store the payment method with us so that
	// it can be used again for future use. This is only supported for payment
	// methods that support this feature.
	Store *bool `json:"store,omitempty"`
}

// Defines the environment to create this transaction in. Setting this to
// anything other than `production` will force Gr4vy to use the payment
// a service configured for that environment.
type TransactionRequestEnvironment string

// Defines the intent of this API call. This determines the desired initial
// state of the transaction.
//
// * `approve` - Captures approval for the transaction from the user but does
// not authorize it. This is only available to payment methods that require
// explicit approval, like PayPal.
// * `authorize` - (Default) Optionally approves and then authorizes a
// transaction but does not capture the funds.
// * `capture` - Optionally approves and then authorizes and captures the
// funds of the transaction.
type TransactionRequestIntent string

// A list of transactions.
type Transactions struct {

	// A list of transactions.
	Items *[]Transaction `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A request to capture multiple previously authorized transactions.
type TransactionsBatchCaptureRequest struct {

	// The (partial) amount to capture.
	//
	// When left blank, this will capture the entire amount.
	Amount float32 `json:"amount"`

	// A supported ISO-4217 currency code.
	Currency string `json:"currency"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier,omitempty"`

	// The ID of the transaction to capture.
	TransactionId string `json:"transaction_id"`
}

// User defines model for User.
type User struct {

	// The email address for this user.
	EmailAdress *string `json:"email_adress,omitempty"`

	// The unique Gr4vy ID for this user.
	Id *string `json:"id,omitempty"`

	// The full name of this user.
	Name *string `json:"name,omitempty"`

	// `user`.
	Type *UserType `json:"type,omitempty"`
}

// `user`.
type UserType string

// ListApiKeyPairsParams defines parameters for ListApiKeyPairs.
type ListApiKeyPairsParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// AsyncStorePaymentMethodJSONBody defines parameters for AsyncStorePaymentMethod.
type AsyncStorePaymentMethodJSONBody CardRequest

// AsyncCreateTransactionJSONBody defines parameters for AsyncCreateTransaction.
type AsyncCreateTransactionJSONBody TransactionRequest

// AsyncBatchCaptureTransactionsJSONBody defines parameters for AsyncBatchCaptureTransactions.
type AsyncBatchCaptureTransactionsJSONBody struct {
	Items *[]TransactionsBatchCaptureRequest `json:"items,omitempty"`
}

// AsyncCaptureTransactionJSONBody defines parameters for AsyncCaptureTransaction.
type AsyncCaptureTransactionJSONBody TransactionCaptureRequest

// LoginJSONBody defines parameters for Login.
type LoginJSONBody SessionRequest

// ListBuyersParams defines parameters for ListBuyers.
type ListBuyersParams struct {

	// Filters the results to only the buyers for which the `display_name` or
	// `external_identifier` matches this value. This field allows for a partial
	// match, matching any buyer for which either of the fields partially or
	// completely matches.
	Search *string `json:"search,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// AddBuyerJSONBody defines parameters for AddBuyer.
type AddBuyerJSONBody BuyerRequest

// ListBuyerPaymentMethodsParams defines parameters for ListBuyerPaymentMethods.
type ListBuyerPaymentMethodsParams struct {

	// Filters the results to only the items for which the `buyer` has an
	// `id` that matches this value.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `external_identifier` that matches this value.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// Filters the results to only the items which support this country code. A
	// country is formatted as 2-letter ISO country code.
	Country *string `json:"country,omitempty"`

	// Filters the results to only the items which support this currency code. A
	// currency is formatted as 3-letter ISO currency code.
	Currency *string `json:"currency,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListBuyerPaymentMethodsParamsEnvironment `json:"environment,omitempty"`
}

// ListBuyerPaymentMethodsParamsEnvironment defines parameters for ListBuyerPaymentMethods.
type ListBuyerPaymentMethodsParamsEnvironment string

// UpdateBuyerJSONBody defines parameters for UpdateBuyer.
type UpdateBuyerJSONBody BuyerUpdate

// ListCardsRulesParams defines parameters for ListCardsRules.
type ListCardsRulesParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListCardsRulesParamsEnvironment `json:"environment,omitempty"`
}

// ListCardsRulesParamsEnvironment defines parameters for ListCardsRules.
type ListCardsRulesParamsEnvironment string

// AddCardRuleJSONBody defines parameters for AddCardRule.
type AddCardRuleJSONBody CardRuleRequest

// UpdateCardRuleJSONBody defines parameters for UpdateCardRule.
type UpdateCardRuleJSONBody CardRuleUpdate

// ListPaymentMethodsParams defines parameters for ListPaymentMethods.
type ListPaymentMethodsParams struct {

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentMethodsParamsEnvironment `json:"environment,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `id` that matches this value.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `external_identifier` that matches this value.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListPaymentMethodsParamsEnvironment defines parameters for ListPaymentMethods.
type ListPaymentMethodsParamsEnvironment string

// StorePaymentMethodJSONBody defines parameters for StorePaymentMethod.
type StorePaymentMethodJSONBody CardRequest

// ListPaymentOptionsParams defines parameters for ListPaymentOptions.
type ListPaymentOptionsParams struct {

	// Filters the results to only the items which support this country code. A
	// country is formatted as 2-letter ISO country code.
	Country *string `json:"country,omitempty"`

	// Filters the results to only the items which support this currency code. A
	// currency is formatted as 3-letter ISO currency code.
	Currency *string `json:"currency,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentOptionsParamsEnvironment `json:"environment,omitempty"`
}

// ListPaymentOptionsParamsEnvironment defines parameters for ListPaymentOptions.
type ListPaymentOptionsParamsEnvironment string

// ListPaymentServiceDefinitionsParams defines parameters for ListPaymentServiceDefinitions.
type ListPaymentServiceDefinitionsParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListPaymentServicesParams defines parameters for ListPaymentServices.
type ListPaymentServicesParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`

	// Filters the results to only the items for which the `method` has been set to
	// this value.
	Method *ListPaymentServicesParamsMethod `json:"method,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentServicesParamsEnvironment `json:"environment,omitempty"`
}

// ListPaymentServicesParamsMethod defines parameters for ListPaymentServices.
type ListPaymentServicesParamsMethod string

// ListPaymentServicesParamsEnvironment defines parameters for ListPaymentServices.
type ListPaymentServicesParamsEnvironment string

// AddPaymentServiceJSONBody defines parameters for AddPaymentService.
type AddPaymentServiceJSONBody PaymentServiceRequest

// UpdatePaymentServiceJSONBody defines parameters for UpdatePaymentService.
type UpdatePaymentServiceJSONBody PaymentServiceUpdate

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {

	// Filters the transactions to only the items for which the `id` or
	// `external_identifier` matches this value. This field allows for a partial
	// match, matching any transaction for which either of the fields partially or
	// completely matches.
	Search *string `json:"search,omitempty"`

	// Filters the results to only the transactions for which the `status`
	// matches this value.
	TransactionStatus *ListTransactionsParamsTransactionStatus `json:"transaction_status,omitempty"`

	// Filters the results to only transactions created before this ISO date-time string.
	BeforeCreatedAt *string `json:"before_created_at,omitempty"`

	// Filters the results to only transactions created after this ISO date-time string.
	AfterCreatedAt *string `json:"after_created_at,omitempty"`

	// Filters the results to only transactions last updated before this ISO
	// date-time string.
	BeforeUpdatedAt *string `json:"before_updated_at,omitempty"`

	// Filters the results to only transactions last updated after this ISO
	// date-time string.
	AfterUpdatedAt *string `json:"after_updated_at,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListTransactionsParamsTransactionStatus defines parameters for ListTransactions.
type ListTransactionsParamsTransactionStatus string

// AuthorizeNewTransactionJSONBody defines parameters for AuthorizeNewTransaction.
type AuthorizeNewTransactionJSONBody TransactionRequest

// CaptureTransactionJSONBody defines parameters for CaptureTransaction.
type CaptureTransactionJSONBody TransactionCaptureRequest

// AsyncStorePaymentMethodJSONRequestBody defines body for AsyncStorePaymentMethod for application/json ContentType.
type AsyncStorePaymentMethodJSONRequestBody AsyncStorePaymentMethodJSONBody

// AsyncCreateTransactionJSONRequestBody defines body for AsyncCreateTransaction for application/json ContentType.
type AsyncCreateTransactionJSONRequestBody AsyncCreateTransactionJSONBody

// AsyncBatchCaptureTransactionsJSONRequestBody defines body for AsyncBatchCaptureTransactions for application/json ContentType.
type AsyncBatchCaptureTransactionsJSONRequestBody AsyncBatchCaptureTransactionsJSONBody

// AsyncCaptureTransactionJSONRequestBody defines body for AsyncCaptureTransaction for application/json ContentType.
type AsyncCaptureTransactionJSONRequestBody AsyncCaptureTransactionJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// AddBuyerJSONRequestBody defines body for AddBuyer for application/json ContentType.
type AddBuyerJSONRequestBody AddBuyerJSONBody

// UpdateBuyerJSONRequestBody defines body for UpdateBuyer for application/json ContentType.
type UpdateBuyerJSONRequestBody UpdateBuyerJSONBody

// AddCardRuleJSONRequestBody defines body for AddCardRule for application/json ContentType.
type AddCardRuleJSONRequestBody AddCardRuleJSONBody

// UpdateCardRuleJSONRequestBody defines body for UpdateCardRule for application/json ContentType.
type UpdateCardRuleJSONRequestBody UpdateCardRuleJSONBody

// StorePaymentMethodJSONRequestBody defines body for StorePaymentMethod for application/json ContentType.
type StorePaymentMethodJSONRequestBody StorePaymentMethodJSONBody

// AddPaymentServiceJSONRequestBody defines body for AddPaymentService for application/json ContentType.
type AddPaymentServiceJSONRequestBody AddPaymentServiceJSONBody

// UpdatePaymentServiceJSONRequestBody defines body for UpdatePaymentService for application/json ContentType.
type UpdatePaymentServiceJSONRequestBody UpdatePaymentServiceJSONBody

// AuthorizeNewTransactionJSONRequestBody defines body for AuthorizeNewTransaction for application/json ContentType.
type AuthorizeNewTransactionJSONRequestBody AuthorizeNewTransactionJSONBody

// CaptureTransactionJSONRequestBody defines body for CaptureTransaction for application/json ContentType.
type CaptureTransactionJSONRequestBody CaptureTransactionJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApiKeyPairs request
	ListApiKeyPairs(ctx context.Context, params *ListApiKeyPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyPair request
	CreateApiKeyPair(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeyPair request
	DeleteApiKeyPair(ctx context.Context, apiKeyPairId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AsyncStorePaymentMethod request  with any body
	AsyncStorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AsyncStorePaymentMethod(ctx context.Context, body AsyncStorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AsyncCreateTransaction request  with any body
	AsyncCreateTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AsyncCreateTransaction(ctx context.Context, body AsyncCreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AsyncBatchCaptureTransactions request  with any body
	AsyncBatchCaptureTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AsyncBatchCaptureTransactions(ctx context.Context, body AsyncBatchCaptureTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AsyncAuthorizeTransaction request
	AsyncAuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AsyncCaptureTransaction request  with any body
	AsyncCaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AsyncCaptureTransaction(ctx context.Context, transactionId string, body AsyncCaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request  with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshSession request
	RefreshSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuyers request
	ListBuyers(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBuyer request  with any body
	AddBuyerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBuyer(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuyerPaymentMethods request
	ListBuyerPaymentMethods(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuyer request
	DeleteBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuyer request
	GetBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBuyer request  with any body
	UpdateBuyerWithBody(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBuyer(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCardsRules request
	ListCardsRules(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCardRule request  with any body
	AddCardRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCardRule(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCardRule request
	DeleteCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCardRule request
	GetCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCardRule request  with any body
	UpdateCardRuleWithBody(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCardRule(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentMerchant request
	GetCurrentMerchant(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentMethods request
	ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorePaymentMethod request  with any body
	StorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePaymentMethod(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentMethod request
	DeletePaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentMethod request
	GetPaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentOptions request
	ListPaymentOptions(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentServiceDefinitions request
	ListPaymentServiceDefinitions(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentServiceDefinition request
	GetPaymentServiceDefinition(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentServices request
	ListPaymentServices(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPaymentService request  with any body
	AddPaymentServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPaymentService(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentService request
	DeletePaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentService request
	GetPaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePaymentService request  with any body
	UpdatePaymentServiceWithBody(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePaymentService(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactions request
	ListTransactions(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeNewTransaction request  with any body
	AuthorizeNewTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthorizeNewTransaction(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RedirectTransactionApproval request
	RedirectTransactionApproval(ctx context.Context, transactionApprovalToken string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveTransaction request
	ApproveTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeTransaction request
	AuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaptureTransaction request  with any body
	CaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CaptureTransaction(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefundTransaction request
	RefundTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApiKeyPairs(ctx context.Context, params *ListApiKeyPairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeyPairsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyPair(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyPairRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeyPair(ctx context.Context, apiKeyPairId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyPairRequest(c.Server, apiKeyPairId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncStorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncStorePaymentMethodRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncStorePaymentMethod(ctx context.Context, body AsyncStorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncStorePaymentMethodRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncCreateTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncCreateTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncCreateTransaction(ctx context.Context, body AsyncCreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncCreateTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncBatchCaptureTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncBatchCaptureTransactionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncBatchCaptureTransactions(ctx context.Context, body AsyncBatchCaptureTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncBatchCaptureTransactionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncAuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncAuthorizeTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncCaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncCaptureTransactionRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AsyncCaptureTransaction(ctx context.Context, transactionId string, body AsyncCaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAsyncCaptureTransactionRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuyers(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuyersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuyerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuyerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuyer(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuyerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuyerPaymentMethods(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuyerPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuyerRequest(c.Server, buyerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuyerRequest(c.Server, buyerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuyerWithBody(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuyerRequestWithBody(c.Server, buyerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuyer(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuyerRequest(c.Server, buyerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCardsRules(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCardsRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCardRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCardRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCardRule(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCardRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCardRuleRequest(c.Server, cardRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCardRuleRequest(c.Server, cardRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCardRuleWithBody(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCardRuleRequestWithBody(c.Server, cardRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCardRule(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCardRuleRequest(c.Server, cardRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentMerchant(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentMerchantRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePaymentMethodRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePaymentMethod(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePaymentMethodRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentMethodRequest(c.Server, paymentMethodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentMethodRequest(c.Server, paymentMethodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentOptions(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentServiceDefinitions(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentServiceDefinitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentServiceDefinition(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentServiceDefinitionRequest(c.Server, paymentServiceDefinitionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentServices(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPaymentServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPaymentServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPaymentService(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPaymentServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentServiceRequest(c.Server, paymentServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentServiceRequest(c.Server, paymentServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentServiceWithBody(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentServiceRequestWithBody(c.Server, paymentServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentService(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentServiceRequest(c.Server, paymentServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactions(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeNewTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeNewTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeNewTransaction(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeNewTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectTransactionApproval(ctx context.Context, transactionApprovalToken string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectTransactionApprovalRequest(c.Server, transactionApprovalToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaptureTransactionRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaptureTransaction(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaptureTransactionRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefundTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefundTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApiKeyPairsRequest generates requests for ListApiKeyPairs
func NewListApiKeyPairsRequest(server string, params *ListApiKeyPairsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-key-pairs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyPairRequest generates requests for CreateApiKeyPair
func NewCreateApiKeyPairRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-key-pairs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteApiKeyPairRequest generates requests for DeleteApiKeyPair
func NewDeleteApiKeyPairRequest(server string, apiKeyPairId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api_key_pair_id", runtime.ParamLocationPath, apiKeyPairId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-key-pairs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAsyncStorePaymentMethodRequest calls the generic AsyncStorePaymentMethod builder with application/json body
func NewAsyncStorePaymentMethodRequest(server string, body AsyncStorePaymentMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAsyncStorePaymentMethodRequestWithBody(server, "application/json", bodyReader)
}

// NewAsyncStorePaymentMethodRequestWithBody generates requests for AsyncStorePaymentMethod with any type of body
func NewAsyncStorePaymentMethodRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/async/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAsyncCreateTransactionRequest calls the generic AsyncCreateTransaction builder with application/json body
func NewAsyncCreateTransactionRequest(server string, body AsyncCreateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAsyncCreateTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewAsyncCreateTransactionRequestWithBody generates requests for AsyncCreateTransaction with any type of body
func NewAsyncCreateTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/async/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAsyncBatchCaptureTransactionsRequest calls the generic AsyncBatchCaptureTransactions builder with application/json body
func NewAsyncBatchCaptureTransactionsRequest(server string, body AsyncBatchCaptureTransactionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAsyncBatchCaptureTransactionsRequestWithBody(server, "application/json", bodyReader)
}

// NewAsyncBatchCaptureTransactionsRequestWithBody generates requests for AsyncBatchCaptureTransactions with any type of body
func NewAsyncBatchCaptureTransactionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/async/transactions/batch-capture")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAsyncAuthorizeTransactionRequest generates requests for AsyncAuthorizeTransaction
func NewAsyncAuthorizeTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/async/transactions/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAsyncCaptureTransactionRequest calls the generic AsyncCaptureTransaction builder with application/json body
func NewAsyncCaptureTransactionRequest(server string, transactionId string, body AsyncCaptureTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAsyncCaptureTransactionRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewAsyncCaptureTransactionRequestWithBody generates requests for AsyncCaptureTransaction with any type of body
func NewAsyncCaptureTransactionRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/async/transactions/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshSessionRequest generates requests for RefreshSession
func NewRefreshSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBuyersRequest generates requests for ListBuyers
func NewListBuyersRequest(server string, params *ListBuyersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBuyerRequest calls the generic AddBuyer builder with application/json body
func NewAddBuyerRequest(server string, body AddBuyerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBuyerRequestWithBody(server, "application/json", bodyReader)
}

// NewAddBuyerRequestWithBody generates requests for AddBuyer with any type of body
func NewAddBuyerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuyerPaymentMethodsRequest generates requests for ListBuyerPaymentMethods
func NewListBuyerPaymentMethodsRequest(server string, params *ListBuyerPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.BuyerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_id", runtime.ParamLocationQuery, *params.BuyerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerExternalIdentifier != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_external_identifier", runtime.ParamLocationQuery, *params.BuyerExternalIdentifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Country != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Currency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBuyerRequest generates requests for DeleteBuyer
func NewDeleteBuyerRequest(server string, buyerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuyerRequest generates requests for GetBuyer
func NewGetBuyerRequest(server string, buyerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBuyerRequest calls the generic UpdateBuyer builder with application/json body
func NewUpdateBuyerRequest(server string, buyerId string, body UpdateBuyerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBuyerRequestWithBody(server, buyerId, "application/json", bodyReader)
}

// NewUpdateBuyerRequestWithBody generates requests for UpdateBuyer with any type of body
func NewUpdateBuyerRequestWithBody(server string, buyerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCardsRulesRequest generates requests for ListCardsRules
func NewListCardsRulesRequest(server string, params *ListCardsRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCardRuleRequest calls the generic AddCardRule builder with application/json body
func NewAddCardRuleRequest(server string, body AddCardRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCardRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCardRuleRequestWithBody generates requests for AddCardRule with any type of body
func NewAddCardRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCardRuleRequest generates requests for DeleteCardRule
func NewDeleteCardRuleRequest(server string, cardRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCardRuleRequest generates requests for GetCardRule
func NewGetCardRuleRequest(server string, cardRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCardRuleRequest calls the generic UpdateCardRule builder with application/json body
func NewUpdateCardRuleRequest(server string, cardRuleId string, body UpdateCardRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCardRuleRequestWithBody(server, cardRuleId, "application/json", bodyReader)
}

// NewUpdateCardRuleRequestWithBody generates requests for UpdateCardRule with any type of body
func NewUpdateCardRuleRequestWithBody(server string, cardRuleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentMerchantRequest generates requests for GetCurrentMerchant
func NewGetCurrentMerchantRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/merchants/main")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentMethodsRequest generates requests for ListPaymentMethods
func NewListPaymentMethodsRequest(server string, params *ListPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_id", runtime.ParamLocationQuery, *params.BuyerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerExternalIdentifier != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_external_identifier", runtime.ParamLocationQuery, *params.BuyerExternalIdentifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorePaymentMethodRequest calls the generic StorePaymentMethod builder with application/json body
func NewStorePaymentMethodRequest(server string, body StorePaymentMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorePaymentMethodRequestWithBody(server, "application/json", bodyReader)
}

// NewStorePaymentMethodRequestWithBody generates requests for StorePaymentMethod with any type of body
func NewStorePaymentMethodRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentMethodRequest generates requests for DeletePaymentMethod
func NewDeletePaymentMethodRequest(server string, paymentMethodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, paymentMethodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentMethodRequest generates requests for GetPaymentMethod
func NewGetPaymentMethodRequest(server string, paymentMethodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, paymentMethodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentOptionsRequest generates requests for ListPaymentOptions
func NewListPaymentOptionsRequest(server string, params *ListPaymentOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-options")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Country != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Currency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentServiceDefinitionsRequest generates requests for ListPaymentServiceDefinitions
func NewListPaymentServiceDefinitionsRequest(server string, params *ListPaymentServiceDefinitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-definitions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentServiceDefinitionRequest generates requests for GetPaymentServiceDefinition
func NewGetPaymentServiceDefinitionRequest(server string, paymentServiceDefinitionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_definition_id", runtime.ParamLocationPath, paymentServiceDefinitionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentServicesRequest generates requests for ListPaymentServices
func NewListPaymentServicesRequest(server string, params *ListPaymentServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Method != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "method", runtime.ParamLocationQuery, *params.Method); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPaymentServiceRequest calls the generic AddPaymentService builder with application/json body
func NewAddPaymentServiceRequest(server string, body AddPaymentServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPaymentServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPaymentServiceRequestWithBody generates requests for AddPaymentService with any type of body
func NewAddPaymentServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentServiceRequest generates requests for DeletePaymentService
func NewDeletePaymentServiceRequest(server string, paymentServiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentServiceRequest generates requests for GetPaymentService
func NewGetPaymentServiceRequest(server string, paymentServiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePaymentServiceRequest calls the generic UpdatePaymentService builder with application/json body
func NewUpdatePaymentServiceRequest(server string, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePaymentServiceRequestWithBody(server, paymentServiceId, "application/json", bodyReader)
}

// NewUpdatePaymentServiceRequestWithBody generates requests for UpdatePaymentService with any type of body
func NewUpdatePaymentServiceRequestWithBody(server string, paymentServiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TransactionStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_status", runtime.ParamLocationQuery, *params.TransactionStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BeforeCreatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_created_at", runtime.ParamLocationQuery, *params.BeforeCreatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AfterCreatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_created_at", runtime.ParamLocationQuery, *params.AfterCreatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BeforeUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_updated_at", runtime.ParamLocationQuery, *params.BeforeUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AfterUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_updated_at", runtime.ParamLocationQuery, *params.AfterUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeNewTransactionRequest calls the generic AuthorizeNewTransaction builder with application/json body
func NewAuthorizeNewTransactionRequest(server string, body AuthorizeNewTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthorizeNewTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthorizeNewTransactionRequestWithBody generates requests for AuthorizeNewTransaction with any type of body
func NewAuthorizeNewTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRedirectTransactionApprovalRequest generates requests for RedirectTransactionApproval
func NewRedirectTransactionApprovalRequest(server string, transactionApprovalToken string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_approval_token", runtime.ParamLocationPath, transactionApprovalToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/approvals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveTransactionRequest generates requests for ApproveTransaction
func NewApproveTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeTransactionRequest generates requests for AuthorizeTransaction
func NewAuthorizeTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCaptureTransactionRequest calls the generic CaptureTransaction builder with application/json body
func NewCaptureTransactionRequest(server string, transactionId string, body CaptureTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCaptureTransactionRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewCaptureTransactionRequestWithBody generates requests for CaptureTransaction with any type of body
func NewCaptureTransactionRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefundTransactionRequest generates requests for RefundTransaction
func NewRefundTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApiKeyPairs request
	ListApiKeyPairsWithResponse(ctx context.Context, params *ListApiKeyPairsParams, reqEditors ...RequestEditorFn) (*ListApiKeyPairsResponse, error)

	// CreateApiKeyPair request
	CreateApiKeyPairWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateApiKeyPairResponse, error)

	// DeleteApiKeyPair request
	DeleteApiKeyPairWithResponse(ctx context.Context, apiKeyPairId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyPairResponse, error)

	// AsyncStorePaymentMethod request  with any body
	AsyncStorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncStorePaymentMethodResponse, error)

	AsyncStorePaymentMethodWithResponse(ctx context.Context, body AsyncStorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncStorePaymentMethodResponse, error)

	// AsyncCreateTransaction request  with any body
	AsyncCreateTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncCreateTransactionResponse, error)

	AsyncCreateTransactionWithResponse(ctx context.Context, body AsyncCreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncCreateTransactionResponse, error)

	// AsyncBatchCaptureTransactions request  with any body
	AsyncBatchCaptureTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncBatchCaptureTransactionsResponse, error)

	AsyncBatchCaptureTransactionsWithResponse(ctx context.Context, body AsyncBatchCaptureTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncBatchCaptureTransactionsResponse, error)

	// AsyncAuthorizeTransaction request
	AsyncAuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AsyncAuthorizeTransactionResponse, error)

	// AsyncCaptureTransaction request  with any body
	AsyncCaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncCaptureTransactionResponse, error)

	AsyncCaptureTransactionWithResponse(ctx context.Context, transactionId string, body AsyncCaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncCaptureTransactionResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// Login request  with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// RefreshSession request
	RefreshSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshSessionResponse, error)

	// ListBuyers request
	ListBuyersWithResponse(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*ListBuyersResponse, error)

	// AddBuyer request  with any body
	AddBuyerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error)

	AddBuyerWithResponse(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error)

	// ListBuyerPaymentMethods request
	ListBuyerPaymentMethodsWithResponse(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListBuyerPaymentMethodsResponse, error)

	// DeleteBuyer request
	DeleteBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*DeleteBuyerResponse, error)

	// GetBuyer request
	GetBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*GetBuyerResponse, error)

	// UpdateBuyer request  with any body
	UpdateBuyerWithBodyWithResponse(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error)

	UpdateBuyerWithResponse(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error)

	// ListCardsRules request
	ListCardsRulesWithResponse(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*ListCardsRulesResponse, error)

	// AddCardRule request  with any body
	AddCardRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error)

	AddCardRuleWithResponse(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error)

	// DeleteCardRule request
	DeleteCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*DeleteCardRuleResponse, error)

	// GetCardRule request
	GetCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*GetCardRuleResponse, error)

	// UpdateCardRule request  with any body
	UpdateCardRuleWithBodyWithResponse(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error)

	UpdateCardRuleWithResponse(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error)

	// GetCurrentMerchant request
	GetCurrentMerchantWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentMerchantResponse, error)

	// ListPaymentMethods request
	ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error)

	// StorePaymentMethod request  with any body
	StorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error)

	StorePaymentMethodWithResponse(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error)

	// DeletePaymentMethod request
	DeletePaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error)

	// GetPaymentMethod request
	GetPaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*GetPaymentMethodResponse, error)

	// ListPaymentOptions request
	ListPaymentOptionsWithResponse(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*ListPaymentOptionsResponse, error)

	// ListPaymentServiceDefinitions request
	ListPaymentServiceDefinitionsWithResponse(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*ListPaymentServiceDefinitionsResponse, error)

	// GetPaymentServiceDefinition request
	GetPaymentServiceDefinitionWithResponse(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceDefinitionResponse, error)

	// ListPaymentServices request
	ListPaymentServicesWithResponse(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*ListPaymentServicesResponse, error)

	// AddPaymentService request  with any body
	AddPaymentServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error)

	AddPaymentServiceWithResponse(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error)

	// DeletePaymentService request
	DeletePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*DeletePaymentServiceResponse, error)

	// GetPaymentService request
	GetPaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceResponse, error)

	// UpdatePaymentService request  with any body
	UpdatePaymentServiceWithBodyWithResponse(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error)

	UpdatePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error)

	// ListTransactions request
	ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error)

	// AuthorizeNewTransaction request  with any body
	AuthorizeNewTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error)

	AuthorizeNewTransactionWithResponse(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error)

	// RedirectTransactionApproval request
	RedirectTransactionApprovalWithResponse(ctx context.Context, transactionApprovalToken string, reqEditors ...RequestEditorFn) (*RedirectTransactionApprovalResponse, error)

	// GetTransaction request
	GetTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// ApproveTransaction request
	ApproveTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*ApproveTransactionResponse, error)

	// AuthorizeTransaction request
	AuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AuthorizeTransactionResponse, error)

	// CaptureTransaction request  with any body
	CaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error)

	CaptureTransactionWithResponse(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error)

	// RefundTransaction request
	RefundTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*RefundTransactionResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)
}

type ListApiKeyPairsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIKeyPairs
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListApiKeyPairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeyPairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKeyPair
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AsyncStorePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Status
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AsyncStorePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AsyncStorePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AsyncCreateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Status
	JSON400      *Error400IncorrectJson
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AsyncCreateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AsyncCreateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AsyncBatchCaptureTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Statuses
	JSON400      *Error400IncorrectJson
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AsyncBatchCaptureTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AsyncBatchCaptureTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AsyncAuthorizeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Status
	JSON400      *Error400IncorrectJson
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AsyncAuthorizeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AsyncAuthorizeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AsyncCaptureTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Status
	JSON400      *Error400IncorrectJson
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AsyncCaptureTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AsyncCaptureTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r RefreshSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuyersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyers
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListBuyersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuyersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Buyer
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON409      *Error409DuplicateRecord
}

// Status returns HTTPResponse.Status
func (r AddBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuyerPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethodsTokenized
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r ListBuyerPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuyerPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyer
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyer
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCardsRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRules
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListCardsRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCardsRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CardRule
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AddCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON403      *ErrorGeneric
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRule
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRule
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentMerchantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Merchant
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetCurrentMerchantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentMerchantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethods
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Card
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r StorePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentOptions
	JSON400      *Error400BadRequest
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentServiceDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServiceDefinitions
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentServiceDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentServiceDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentServiceDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServiceDefinition
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentServiceDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentServiceDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServices
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentService
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AddPaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentService
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentService
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdatePaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeNewTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Transaction
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AuthorizeNewTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeNewTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RedirectTransactionApprovalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r RedirectTransactionApprovalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RedirectTransactionApprovalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON401      *Error401Unauthorized
	JSON404      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r ApproveTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *interface{}
}

// Status returns HTTPResponse.Status
func (r AuthorizeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaptureTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *interface{}
	JSON401      *Error401Unauthorized
	JSON404      *interface{}
}

// Status returns HTTPResponse.Status
func (r CaptureTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaptureTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefundTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON401      *Error401Unauthorized
	JSON404      *interface{}
}

// Status returns HTTPResponse.Status
func (r RefundTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefundTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApiKeyPairsWithResponse request returning *ListApiKeyPairsResponse
func (c *ClientWithResponses) ListApiKeyPairsWithResponse(ctx context.Context, params *ListApiKeyPairsParams, reqEditors ...RequestEditorFn) (*ListApiKeyPairsResponse, error) {
	rsp, err := c.ListApiKeyPairs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeyPairsResponse(rsp)
}

// CreateApiKeyPairWithResponse request returning *CreateApiKeyPairResponse
func (c *ClientWithResponses) CreateApiKeyPairWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateApiKeyPairResponse, error) {
	rsp, err := c.CreateApiKeyPair(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyPairResponse(rsp)
}

// DeleteApiKeyPairWithResponse request returning *DeleteApiKeyPairResponse
func (c *ClientWithResponses) DeleteApiKeyPairWithResponse(ctx context.Context, apiKeyPairId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyPairResponse, error) {
	rsp, err := c.DeleteApiKeyPair(ctx, apiKeyPairId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyPairResponse(rsp)
}

// AsyncStorePaymentMethodWithBodyWithResponse request with arbitrary body returning *AsyncStorePaymentMethodResponse
func (c *ClientWithResponses) AsyncStorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncStorePaymentMethodResponse, error) {
	rsp, err := c.AsyncStorePaymentMethodWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncStorePaymentMethodResponse(rsp)
}

func (c *ClientWithResponses) AsyncStorePaymentMethodWithResponse(ctx context.Context, body AsyncStorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncStorePaymentMethodResponse, error) {
	rsp, err := c.AsyncStorePaymentMethod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncStorePaymentMethodResponse(rsp)
}

// AsyncCreateTransactionWithBodyWithResponse request with arbitrary body returning *AsyncCreateTransactionResponse
func (c *ClientWithResponses) AsyncCreateTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncCreateTransactionResponse, error) {
	rsp, err := c.AsyncCreateTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncCreateTransactionResponse(rsp)
}

func (c *ClientWithResponses) AsyncCreateTransactionWithResponse(ctx context.Context, body AsyncCreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncCreateTransactionResponse, error) {
	rsp, err := c.AsyncCreateTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncCreateTransactionResponse(rsp)
}

// AsyncBatchCaptureTransactionsWithBodyWithResponse request with arbitrary body returning *AsyncBatchCaptureTransactionsResponse
func (c *ClientWithResponses) AsyncBatchCaptureTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncBatchCaptureTransactionsResponse, error) {
	rsp, err := c.AsyncBatchCaptureTransactionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncBatchCaptureTransactionsResponse(rsp)
}

func (c *ClientWithResponses) AsyncBatchCaptureTransactionsWithResponse(ctx context.Context, body AsyncBatchCaptureTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncBatchCaptureTransactionsResponse, error) {
	rsp, err := c.AsyncBatchCaptureTransactions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncBatchCaptureTransactionsResponse(rsp)
}

// AsyncAuthorizeTransactionWithResponse request returning *AsyncAuthorizeTransactionResponse
func (c *ClientWithResponses) AsyncAuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AsyncAuthorizeTransactionResponse, error) {
	rsp, err := c.AsyncAuthorizeTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncAuthorizeTransactionResponse(rsp)
}

// AsyncCaptureTransactionWithBodyWithResponse request with arbitrary body returning *AsyncCaptureTransactionResponse
func (c *ClientWithResponses) AsyncCaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AsyncCaptureTransactionResponse, error) {
	rsp, err := c.AsyncCaptureTransactionWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncCaptureTransactionResponse(rsp)
}

func (c *ClientWithResponses) AsyncCaptureTransactionWithResponse(ctx context.Context, transactionId string, body AsyncCaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AsyncCaptureTransactionResponse, error) {
	rsp, err := c.AsyncCaptureTransaction(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAsyncCaptureTransactionResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// RefreshSessionWithResponse request returning *RefreshSessionResponse
func (c *ClientWithResponses) RefreshSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshSessionResponse, error) {
	rsp, err := c.RefreshSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshSessionResponse(rsp)
}

// ListBuyersWithResponse request returning *ListBuyersResponse
func (c *ClientWithResponses) ListBuyersWithResponse(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*ListBuyersResponse, error) {
	rsp, err := c.ListBuyers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuyersResponse(rsp)
}

// AddBuyerWithBodyWithResponse request with arbitrary body returning *AddBuyerResponse
func (c *ClientWithResponses) AddBuyerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error) {
	rsp, err := c.AddBuyerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuyerResponse(rsp)
}

func (c *ClientWithResponses) AddBuyerWithResponse(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error) {
	rsp, err := c.AddBuyer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuyerResponse(rsp)
}

// ListBuyerPaymentMethodsWithResponse request returning *ListBuyerPaymentMethodsResponse
func (c *ClientWithResponses) ListBuyerPaymentMethodsWithResponse(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListBuyerPaymentMethodsResponse, error) {
	rsp, err := c.ListBuyerPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuyerPaymentMethodsResponse(rsp)
}

// DeleteBuyerWithResponse request returning *DeleteBuyerResponse
func (c *ClientWithResponses) DeleteBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*DeleteBuyerResponse, error) {
	rsp, err := c.DeleteBuyer(ctx, buyerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuyerResponse(rsp)
}

// GetBuyerWithResponse request returning *GetBuyerResponse
func (c *ClientWithResponses) GetBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*GetBuyerResponse, error) {
	rsp, err := c.GetBuyer(ctx, buyerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuyerResponse(rsp)
}

// UpdateBuyerWithBodyWithResponse request with arbitrary body returning *UpdateBuyerResponse
func (c *ClientWithResponses) UpdateBuyerWithBodyWithResponse(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error) {
	rsp, err := c.UpdateBuyerWithBody(ctx, buyerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuyerResponse(rsp)
}

func (c *ClientWithResponses) UpdateBuyerWithResponse(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error) {
	rsp, err := c.UpdateBuyer(ctx, buyerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuyerResponse(rsp)
}

// ListCardsRulesWithResponse request returning *ListCardsRulesResponse
func (c *ClientWithResponses) ListCardsRulesWithResponse(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*ListCardsRulesResponse, error) {
	rsp, err := c.ListCardsRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCardsRulesResponse(rsp)
}

// AddCardRuleWithBodyWithResponse request with arbitrary body returning *AddCardRuleResponse
func (c *ClientWithResponses) AddCardRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error) {
	rsp, err := c.AddCardRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCardRuleResponse(rsp)
}

func (c *ClientWithResponses) AddCardRuleWithResponse(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error) {
	rsp, err := c.AddCardRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCardRuleResponse(rsp)
}

// DeleteCardRuleWithResponse request returning *DeleteCardRuleResponse
func (c *ClientWithResponses) DeleteCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*DeleteCardRuleResponse, error) {
	rsp, err := c.DeleteCardRule(ctx, cardRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCardRuleResponse(rsp)
}

// GetCardRuleWithResponse request returning *GetCardRuleResponse
func (c *ClientWithResponses) GetCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*GetCardRuleResponse, error) {
	rsp, err := c.GetCardRule(ctx, cardRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCardRuleResponse(rsp)
}

// UpdateCardRuleWithBodyWithResponse request with arbitrary body returning *UpdateCardRuleResponse
func (c *ClientWithResponses) UpdateCardRuleWithBodyWithResponse(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error) {
	rsp, err := c.UpdateCardRuleWithBody(ctx, cardRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCardRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateCardRuleWithResponse(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error) {
	rsp, err := c.UpdateCardRule(ctx, cardRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCardRuleResponse(rsp)
}

// GetCurrentMerchantWithResponse request returning *GetCurrentMerchantResponse
func (c *ClientWithResponses) GetCurrentMerchantWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentMerchantResponse, error) {
	rsp, err := c.GetCurrentMerchant(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentMerchantResponse(rsp)
}

// ListPaymentMethodsWithResponse request returning *ListPaymentMethodsResponse
func (c *ClientWithResponses) ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error) {
	rsp, err := c.ListPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentMethodsResponse(rsp)
}

// StorePaymentMethodWithBodyWithResponse request with arbitrary body returning *StorePaymentMethodResponse
func (c *ClientWithResponses) StorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error) {
	rsp, err := c.StorePaymentMethodWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePaymentMethodResponse(rsp)
}

func (c *ClientWithResponses) StorePaymentMethodWithResponse(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error) {
	rsp, err := c.StorePaymentMethod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePaymentMethodResponse(rsp)
}

// DeletePaymentMethodWithResponse request returning *DeletePaymentMethodResponse
func (c *ClientWithResponses) DeletePaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error) {
	rsp, err := c.DeletePaymentMethod(ctx, paymentMethodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentMethodResponse(rsp)
}

// GetPaymentMethodWithResponse request returning *GetPaymentMethodResponse
func (c *ClientWithResponses) GetPaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*GetPaymentMethodResponse, error) {
	rsp, err := c.GetPaymentMethod(ctx, paymentMethodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentMethodResponse(rsp)
}

// ListPaymentOptionsWithResponse request returning *ListPaymentOptionsResponse
func (c *ClientWithResponses) ListPaymentOptionsWithResponse(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*ListPaymentOptionsResponse, error) {
	rsp, err := c.ListPaymentOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentOptionsResponse(rsp)
}

// ListPaymentServiceDefinitionsWithResponse request returning *ListPaymentServiceDefinitionsResponse
func (c *ClientWithResponses) ListPaymentServiceDefinitionsWithResponse(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*ListPaymentServiceDefinitionsResponse, error) {
	rsp, err := c.ListPaymentServiceDefinitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentServiceDefinitionsResponse(rsp)
}

// GetPaymentServiceDefinitionWithResponse request returning *GetPaymentServiceDefinitionResponse
func (c *ClientWithResponses) GetPaymentServiceDefinitionWithResponse(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceDefinitionResponse, error) {
	rsp, err := c.GetPaymentServiceDefinition(ctx, paymentServiceDefinitionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentServiceDefinitionResponse(rsp)
}

// ListPaymentServicesWithResponse request returning *ListPaymentServicesResponse
func (c *ClientWithResponses) ListPaymentServicesWithResponse(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*ListPaymentServicesResponse, error) {
	rsp, err := c.ListPaymentServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentServicesResponse(rsp)
}

// AddPaymentServiceWithBodyWithResponse request with arbitrary body returning *AddPaymentServiceResponse
func (c *ClientWithResponses) AddPaymentServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error) {
	rsp, err := c.AddPaymentServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPaymentServiceResponse(rsp)
}

func (c *ClientWithResponses) AddPaymentServiceWithResponse(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error) {
	rsp, err := c.AddPaymentService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPaymentServiceResponse(rsp)
}

// DeletePaymentServiceWithResponse request returning *DeletePaymentServiceResponse
func (c *ClientWithResponses) DeletePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*DeletePaymentServiceResponse, error) {
	rsp, err := c.DeletePaymentService(ctx, paymentServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentServiceResponse(rsp)
}

// GetPaymentServiceWithResponse request returning *GetPaymentServiceResponse
func (c *ClientWithResponses) GetPaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceResponse, error) {
	rsp, err := c.GetPaymentService(ctx, paymentServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentServiceResponse(rsp)
}

// UpdatePaymentServiceWithBodyWithResponse request with arbitrary body returning *UpdatePaymentServiceResponse
func (c *ClientWithResponses) UpdatePaymentServiceWithBodyWithResponse(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error) {
	rsp, err := c.UpdatePaymentServiceWithBody(ctx, paymentServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error) {
	rsp, err := c.UpdatePaymentService(ctx, paymentServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentServiceResponse(rsp)
}

// ListTransactionsWithResponse request returning *ListTransactionsResponse
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error) {
	rsp, err := c.ListTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResponse(rsp)
}

// AuthorizeNewTransactionWithBodyWithResponse request with arbitrary body returning *AuthorizeNewTransactionResponse
func (c *ClientWithResponses) AuthorizeNewTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error) {
	rsp, err := c.AuthorizeNewTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeNewTransactionResponse(rsp)
}

func (c *ClientWithResponses) AuthorizeNewTransactionWithResponse(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error) {
	rsp, err := c.AuthorizeNewTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeNewTransactionResponse(rsp)
}

// RedirectTransactionApprovalWithResponse request returning *RedirectTransactionApprovalResponse
func (c *ClientWithResponses) RedirectTransactionApprovalWithResponse(ctx context.Context, transactionApprovalToken string, reqEditors ...RequestEditorFn) (*RedirectTransactionApprovalResponse, error) {
	rsp, err := c.RedirectTransactionApproval(ctx, transactionApprovalToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectTransactionApprovalResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// ApproveTransactionWithResponse request returning *ApproveTransactionResponse
func (c *ClientWithResponses) ApproveTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*ApproveTransactionResponse, error) {
	rsp, err := c.ApproveTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveTransactionResponse(rsp)
}

// AuthorizeTransactionWithResponse request returning *AuthorizeTransactionResponse
func (c *ClientWithResponses) AuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AuthorizeTransactionResponse, error) {
	rsp, err := c.AuthorizeTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeTransactionResponse(rsp)
}

// CaptureTransactionWithBodyWithResponse request with arbitrary body returning *CaptureTransactionResponse
func (c *ClientWithResponses) CaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error) {
	rsp, err := c.CaptureTransactionWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaptureTransactionResponse(rsp)
}

func (c *ClientWithResponses) CaptureTransactionWithResponse(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error) {
	rsp, err := c.CaptureTransaction(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaptureTransactionResponse(rsp)
}

// RefundTransactionWithResponse request returning *RefundTransactionResponse
func (c *ClientWithResponses) RefundTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*RefundTransactionResponse, error) {
	rsp, err := c.RefundTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefundTransactionResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ParseListApiKeyPairsResponse parses an HTTP response from a ListApiKeyPairsWithResponse call
func ParseListApiKeyPairsResponse(rsp *http.Response) (*ListApiKeyPairsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeyPairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIKeyPairs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyPairResponse parses an HTTP response from a CreateApiKeyPairWithResponse call
func ParseCreateApiKeyPairResponse(rsp *http.Response) (*CreateApiKeyPairResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKeyPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyPairResponse parses an HTTP response from a DeleteApiKeyPairWithResponse call
func ParseDeleteApiKeyPairResponse(rsp *http.Response) (*DeleteApiKeyPairResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAsyncStorePaymentMethodResponse parses an HTTP response from a AsyncStorePaymentMethodWithResponse call
func ParseAsyncStorePaymentMethodResponse(rsp *http.Response) (*AsyncStorePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AsyncStorePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAsyncCreateTransactionResponse parses an HTTP response from a AsyncCreateTransactionWithResponse call
func ParseAsyncCreateTransactionResponse(rsp *http.Response) (*AsyncCreateTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AsyncCreateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400IncorrectJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAsyncBatchCaptureTransactionsResponse parses an HTTP response from a AsyncBatchCaptureTransactionsWithResponse call
func ParseAsyncBatchCaptureTransactionsResponse(rsp *http.Response) (*AsyncBatchCaptureTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AsyncBatchCaptureTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Statuses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400IncorrectJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAsyncAuthorizeTransactionResponse parses an HTTP response from a AsyncAuthorizeTransactionWithResponse call
func ParseAsyncAuthorizeTransactionResponse(rsp *http.Response) (*AsyncAuthorizeTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AsyncAuthorizeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400IncorrectJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAsyncCaptureTransactionResponse parses an HTTP response from a AsyncCaptureTransactionWithResponse call
func ParseAsyncCaptureTransactionResponse(rsp *http.Response) (*AsyncCaptureTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AsyncCaptureTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400IncorrectJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRefreshSessionResponse parses an HTTP response from a RefreshSessionWithResponse call
func ParseRefreshSessionResponse(rsp *http.Response) (*RefreshSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RefreshSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListBuyersResponse parses an HTTP response from a ListBuyersWithResponse call
func ParseListBuyersResponse(rsp *http.Response) (*ListBuyersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBuyersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddBuyerResponse parses an HTTP response from a AddBuyerWithResponse call
func ParseAddBuyerResponse(rsp *http.Response) (*AddBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409DuplicateRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseListBuyerPaymentMethodsResponse parses an HTTP response from a ListBuyerPaymentMethodsWithResponse call
func ParseListBuyerPaymentMethodsResponse(rsp *http.Response) (*ListBuyerPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBuyerPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethodsTokenized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBuyerResponse parses an HTTP response from a DeleteBuyerWithResponse call
func ParseDeleteBuyerResponse(rsp *http.Response) (*DeleteBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBuyerResponse parses an HTTP response from a GetBuyerWithResponse call
func ParseGetBuyerResponse(rsp *http.Response) (*GetBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBuyerResponse parses an HTTP response from a UpdateBuyerWithResponse call
func ParseUpdateBuyerResponse(rsp *http.Response) (*UpdateBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCardsRulesResponse parses an HTTP response from a ListCardsRulesWithResponse call
func ParseListCardsRulesResponse(rsp *http.Response) (*ListCardsRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCardsRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddCardRuleResponse parses an HTTP response from a AddCardRuleWithResponse call
func ParseAddCardRuleResponse(rsp *http.Response) (*AddCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCardRuleResponse parses an HTTP response from a DeleteCardRuleWithResponse call
func ParseDeleteCardRuleResponse(rsp *http.Response) (*DeleteCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCardRuleResponse parses an HTTP response from a GetCardRuleWithResponse call
func ParseGetCardRuleResponse(rsp *http.Response) (*GetCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCardRuleResponse parses an HTTP response from a UpdateCardRuleWithResponse call
func ParseUpdateCardRuleResponse(rsp *http.Response) (*UpdateCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCurrentMerchantResponse parses an HTTP response from a GetCurrentMerchantWithResponse call
func ParseGetCurrentMerchantResponse(rsp *http.Response) (*GetCurrentMerchantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentMerchantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Merchant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentMethodsResponse parses an HTTP response from a ListPaymentMethodsWithResponse call
func ParseListPaymentMethodsResponse(rsp *http.Response) (*ListPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseStorePaymentMethodResponse parses an HTTP response from a StorePaymentMethodWithResponse call
func ParseStorePaymentMethodResponse(rsp *http.Response) (*StorePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StorePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Card
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePaymentMethodResponse parses an HTTP response from a DeletePaymentMethodWithResponse call
func ParseDeletePaymentMethodResponse(rsp *http.Response) (*DeletePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPaymentMethodResponse parses an HTTP response from a GetPaymentMethodWithResponse call
func ParseGetPaymentMethodResponse(rsp *http.Response) (*GetPaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentOptionsResponse parses an HTTP response from a ListPaymentOptionsWithResponse call
func ParseListPaymentOptionsResponse(rsp *http.Response) (*ListPaymentOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPaymentServiceDefinitionsResponse parses an HTTP response from a ListPaymentServiceDefinitionsWithResponse call
func ParseListPaymentServiceDefinitionsResponse(rsp *http.Response) (*ListPaymentServiceDefinitionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentServiceDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServiceDefinitions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPaymentServiceDefinitionResponse parses an HTTP response from a GetPaymentServiceDefinitionWithResponse call
func ParseGetPaymentServiceDefinitionResponse(rsp *http.Response) (*GetPaymentServiceDefinitionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentServiceDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServiceDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentServicesResponse parses an HTTP response from a ListPaymentServicesWithResponse call
func ParseListPaymentServicesResponse(rsp *http.Response) (*ListPaymentServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddPaymentServiceResponse parses an HTTP response from a AddPaymentServiceWithResponse call
func ParseAddPaymentServiceResponse(rsp *http.Response) (*AddPaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddPaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePaymentServiceResponse parses an HTTP response from a DeletePaymentServiceWithResponse call
func ParseDeletePaymentServiceResponse(rsp *http.Response) (*DeletePaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPaymentServiceResponse parses an HTTP response from a GetPaymentServiceWithResponse call
func ParseGetPaymentServiceResponse(rsp *http.Response) (*GetPaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePaymentServiceResponse parses an HTTP response from a UpdatePaymentServiceWithResponse call
func ParseUpdatePaymentServiceResponse(rsp *http.Response) (*UpdatePaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListTransactionsResponse parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResponse(rsp *http.Response) (*ListTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAuthorizeNewTransactionResponse parses an HTTP response from a AuthorizeNewTransactionWithResponse call
func ParseAuthorizeNewTransactionResponse(rsp *http.Response) (*AuthorizeNewTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeNewTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRedirectTransactionApprovalResponse parses an HTTP response from a RedirectTransactionApprovalWithResponse call
func ParseRedirectTransactionApprovalResponse(rsp *http.Response) (*RedirectTransactionApprovalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RedirectTransactionApprovalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseApproveTransactionResponse parses an HTTP response from a ApproveTransactionWithResponse call
func ParseApproveTransactionResponse(rsp *http.Response) (*ApproveTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ApproveTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAuthorizeTransactionResponse parses an HTTP response from a AuthorizeTransactionWithResponse call
func ParseAuthorizeTransactionResponse(rsp *http.Response) (*AuthorizeTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCaptureTransactionResponse parses an HTTP response from a CaptureTransactionWithResponse call
func ParseCaptureTransactionResponse(rsp *http.Response) (*CaptureTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CaptureTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRefundTransactionResponse parses an HTTP response from a RefundTransactionWithResponse call
func ParseRefundTransactionResponse(rsp *http.Response) (*RefundTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RefundTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List API key-pairs
	// (GET /api-key-pairs)
	ListApiKeyPairs(ctx echo.Context, params ListApiKeyPairsParams) error
	// Create an API key-pair
	// (POST /api-key-pairs)
	CreateApiKeyPair(ctx echo.Context) error
	// Delete an API key-pair
	// (DELETE /api-key-pairs/{api_key_pair_id})
	DeleteApiKeyPair(ctx echo.Context, apiKeyPairId string) error
	// Store a new payment method
	// (POST /async/payment-methods)
	AsyncStorePaymentMethod(ctx echo.Context) error
	// Create transaction
	// (POST /async/transactions)
	AsyncCreateTransaction(ctx echo.Context) error
	// Batch capture transactions
	// (POST /async/transactions/batch-capture)
	AsyncBatchCaptureTransactions(ctx echo.Context) error
	// Authorize approved transaction
	// (POST /async/transactions/{transaction_id}/authorize)
	AsyncAuthorizeTransaction(ctx echo.Context, transactionId string) error
	// Capture transaction
	// (POST /async/transactions/{transaction_id}/capture)
	AsyncCaptureTransaction(ctx echo.Context, transactionId string) error
	// Ends a user session (Logout)
	// (DELETE /auth/sessions)
	Logout(ctx echo.Context) error
	// Create a user session (Login)
	// (POST /auth/sessions)
	Login(ctx echo.Context) error
	// Renew a user session
	// (PUT /auth/sessions)
	RefreshSession(ctx echo.Context) error
	// List buyers
	// (GET /buyers)
	ListBuyers(ctx echo.Context, params ListBuyersParams) error
	// New buyer
	// (POST /buyers)
	AddBuyer(ctx echo.Context) error
	// List stored payment methods for a buyer
	// (GET /buyers/payment-methods)
	ListBuyerPaymentMethods(ctx echo.Context, params ListBuyerPaymentMethodsParams) error
	// Delete buyer
	// (DELETE /buyers/{buyer_id})
	DeleteBuyer(ctx echo.Context, buyerId string) error
	// Get buyer
	// (GET /buyers/{buyer_id})
	GetBuyer(ctx echo.Context, buyerId string) error
	// Update buyer
	// (PUT /buyers/{buyer_id})
	UpdateBuyer(ctx echo.Context, buyerId string) error
	// List card rules
	// (GET /card-rules)
	ListCardsRules(ctx echo.Context, params ListCardsRulesParams) error
	// Create card rule
	// (POST /card-rules)
	AddCardRule(ctx echo.Context) error
	// Delete card rule
	// (DELETE /card-rules/{card_rule_id})
	DeleteCardRule(ctx echo.Context, cardRuleId string) error
	// Get card rule
	// (GET /card-rules/{card_rule_id})
	GetCardRule(ctx echo.Context, cardRuleId string) error
	// Update card rule
	// (PUT /card-rules/{card_rule_id})
	UpdateCardRule(ctx echo.Context, cardRuleId string) error
	// Get current merchant details
	// (GET /merchants/main)
	GetCurrentMerchant(ctx echo.Context) error
	// List payment methods
	// (GET /payment-methods)
	ListPaymentMethods(ctx echo.Context, params ListPaymentMethodsParams) error
	// New payment method
	// (POST /payment-methods)
	StorePaymentMethod(ctx echo.Context) error
	// Delete payment method
	// (DELETE /payment-methods/{payment_method_id})
	DeletePaymentMethod(ctx echo.Context, paymentMethodId string) error
	// Get stored payment method
	// (GET /payment-methods/{payment_method_id})
	GetPaymentMethod(ctx echo.Context, paymentMethodId string) error
	// List payment options
	// (GET /payment-options)
	ListPaymentOptions(ctx echo.Context, params ListPaymentOptionsParams) error
	// List payment service definitions
	// (GET /payment-service-definitions)
	ListPaymentServiceDefinitions(ctx echo.Context, params ListPaymentServiceDefinitionsParams) error
	// Get payment service definition
	// (GET /payment-service-definitions/{payment_service_definition_id})
	GetPaymentServiceDefinition(ctx echo.Context, paymentServiceDefinitionId string) error
	// List payment services
	// (GET /payment-services)
	ListPaymentServices(ctx echo.Context, params ListPaymentServicesParams) error
	// New payment service
	// (POST /payment-services)
	AddPaymentService(ctx echo.Context) error
	// Delete payment service
	// (DELETE /payment-services/{payment_service_id})
	DeletePaymentService(ctx echo.Context, paymentServiceId string) error
	// Get payment service
	// (GET /payment-services/{payment_service_id})
	GetPaymentService(ctx echo.Context, paymentServiceId string) error
	// Update payment service
	// (PUT /payment-services/{payment_service_id})
	UpdatePaymentService(ctx echo.Context, paymentServiceId string) error
	// List transactions
	// (GET /transactions)
	ListTransactions(ctx echo.Context, params ListTransactionsParams) error
	// New transaction
	// (POST /transactions)
	AuthorizeNewTransaction(ctx echo.Context) error
	// Approve payment method
	// (GET /transactions/approvals/{transaction_approval_token})
	RedirectTransactionApproval(ctx echo.Context, transactionApprovalToken string) error
	// Get transaction
	// (GET /transactions/{transaction_id})
	GetTransaction(ctx echo.Context, transactionId string) error
	// Buyer approval callback
	// (GET /transactions/{transaction_id}/approve)
	ApproveTransaction(ctx echo.Context, transactionId string) error
	// Authorize approved transaction
	// (POST /transactions/{transaction_id}/authorize)
	AuthorizeTransaction(ctx echo.Context, transactionId string) error
	// Capture transaction
	// (POST /transactions/{transaction_id}/capture)
	CaptureTransaction(ctx echo.Context, transactionId string) error
	// Refund or void transaction
	// (POST /transactions/{transaction_id}/refund)
	RefundTransaction(ctx echo.Context, transactionId string) error
	// Get current
	// (GET /users/me)
	GetCurrentUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListApiKeyPairs converts echo context to params.
func (w *ServerInterfaceWrapper) ListApiKeyPairs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListApiKeyPairsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListApiKeyPairs(ctx, params)
	return err
}

// CreateApiKeyPair converts echo context to params.
func (w *ServerInterfaceWrapper) CreateApiKeyPair(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateApiKeyPair(ctx)
	return err
}

// DeleteApiKeyPair converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteApiKeyPair(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "api_key_pair_id" -------------
	var apiKeyPairId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "api_key_pair_id", runtime.ParamLocationPath, ctx.Param("api_key_pair_id"), &apiKeyPairId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter api_key_pair_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteApiKeyPair(ctx, apiKeyPairId)
	return err
}

// AsyncStorePaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) AsyncStorePaymentMethod(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AsyncStorePaymentMethod(ctx)
	return err
}

// AsyncCreateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AsyncCreateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AsyncCreateTransaction(ctx)
	return err
}

// AsyncBatchCaptureTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) AsyncBatchCaptureTransactions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AsyncBatchCaptureTransactions(ctx)
	return err
}

// AsyncAuthorizeTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AsyncAuthorizeTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AsyncAuthorizeTransaction(ctx, transactionId)
	return err
}

// AsyncCaptureTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AsyncCaptureTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AsyncCaptureTransaction(ctx, transactionId)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Login(ctx)
	return err
}

// RefreshSession converts echo context to params.
func (w *ServerInterfaceWrapper) RefreshSession(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RefreshSession(ctx)
	return err
}

// ListBuyers converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuyers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuyersParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBuyers(ctx, params)
	return err
}

// AddBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) AddBuyer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddBuyer(ctx)
	return err
}

// ListBuyerPaymentMethods converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuyerPaymentMethods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuyerPaymentMethodsParams
	// ------------- Optional query parameter "buyer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_id", ctx.QueryParams(), &params.BuyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	// ------------- Optional query parameter "buyer_external_identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_external_identifier", ctx.QueryParams(), &params.BuyerExternalIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_external_identifier: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "currency" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency", ctx.QueryParams(), &params.Currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBuyerPaymentMethods(ctx, params)
	return err
}

// DeleteBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteBuyer(ctx, buyerId)
	return err
}

// GetBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) GetBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBuyer(ctx, buyerId)
	return err
}

// UpdateBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateBuyer(ctx, buyerId)
	return err
}

// ListCardsRules converts echo context to params.
func (w *ServerInterfaceWrapper) ListCardsRules(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCardsRulesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListCardsRules(ctx, params)
	return err
}

// AddCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) AddCardRule(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddCardRule(ctx)
	return err
}

// DeleteCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCardRule(ctx, cardRuleId)
	return err
}

// GetCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) GetCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCardRule(ctx, cardRuleId)
	return err
}

// UpdateCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCardRule(ctx, cardRuleId)
	return err
}

// GetCurrentMerchant converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentMerchant(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentMerchant(ctx)
	return err
}

// ListPaymentMethods converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentMethods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentMethodsParams
	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// ------------- Optional query parameter "buyer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_id", ctx.QueryParams(), &params.BuyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	// ------------- Optional query parameter "buyer_external_identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_external_identifier", ctx.QueryParams(), &params.BuyerExternalIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_external_identifier: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentMethods(ctx, params)
	return err
}

// StorePaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) StorePaymentMethod(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StorePaymentMethod(ctx)
	return err
}

// DeletePaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePaymentMethod(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_method_id" -------------
	var paymentMethodId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, ctx.Param("payment_method_id"), &paymentMethodId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_method_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePaymentMethod(ctx, paymentMethodId)
	return err
}

// GetPaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentMethod(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_method_id" -------------
	var paymentMethodId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, ctx.Param("payment_method_id"), &paymentMethodId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_method_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentMethod(ctx, paymentMethodId)
	return err
}

// ListPaymentOptions converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentOptions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentOptionsParams
	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "currency" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency", ctx.QueryParams(), &params.Currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentOptions(ctx, params)
	return err
}

// ListPaymentServiceDefinitions converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentServiceDefinitions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentServiceDefinitionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentServiceDefinitions(ctx, params)
	return err
}

// GetPaymentServiceDefinition converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentServiceDefinition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_definition_id" -------------
	var paymentServiceDefinitionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_definition_id", runtime.ParamLocationPath, ctx.Param("payment_service_definition_id"), &paymentServiceDefinitionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_definition_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentServiceDefinition(ctx, paymentServiceDefinitionId)
	return err
}

// ListPaymentServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentServicesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "method" -------------

	err = runtime.BindQueryParameter("form", true, false, "method", ctx.QueryParams(), &params.Method)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter method: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentServices(ctx, params)
	return err
}

// AddPaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) AddPaymentService(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddPaymentService(ctx)
	return err
}

// DeletePaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePaymentService(ctx, paymentServiceId)
	return err
}

// GetPaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentService(ctx, paymentServiceId)
	return err
}

// UpdatePaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdatePaymentService(ctx, paymentServiceId)
	return err
}

// ListTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) ListTransactions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTransactionsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// ------------- Optional query parameter "transaction_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "transaction_status", ctx.QueryParams(), &params.TransactionStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_status: %s", err))
	}

	// ------------- Optional query parameter "before_created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "before_created_at", ctx.QueryParams(), &params.BeforeCreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before_created_at: %s", err))
	}

	// ------------- Optional query parameter "after_created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_created_at", ctx.QueryParams(), &params.AfterCreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after_created_at: %s", err))
	}

	// ------------- Optional query parameter "before_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "before_updated_at", ctx.QueryParams(), &params.BeforeUpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before_updated_at: %s", err))
	}

	// ------------- Optional query parameter "after_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_updated_at", ctx.QueryParams(), &params.AfterUpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after_updated_at: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListTransactions(ctx, params)
	return err
}

// AuthorizeNewTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AuthorizeNewTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthorizeNewTransaction(ctx)
	return err
}

// RedirectTransactionApproval converts echo context to params.
func (w *ServerInterfaceWrapper) RedirectTransactionApproval(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_approval_token" -------------
	var transactionApprovalToken string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_approval_token", runtime.ParamLocationPath, ctx.Param("transaction_approval_token"), &transactionApprovalToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_approval_token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RedirectTransactionApproval(ctx, transactionApprovalToken)
	return err
}

// GetTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransaction(ctx, transactionId)
	return err
}

// ApproveTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) ApproveTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApproveTransaction(ctx, transactionId)
	return err
}

// AuthorizeTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AuthorizeTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthorizeTransaction(ctx, transactionId)
	return err
}

// CaptureTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) CaptureTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CaptureTransaction(ctx, transactionId)
	return err
}

// RefundTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RefundTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RefundTransaction(ctx, transactionId)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api-key-pairs", wrapper.ListApiKeyPairs)
	router.POST(baseURL+"/api-key-pairs", wrapper.CreateApiKeyPair)
	router.DELETE(baseURL+"/api-key-pairs/:api_key_pair_id", wrapper.DeleteApiKeyPair)
	router.POST(baseURL+"/async/payment-methods", wrapper.AsyncStorePaymentMethod)
	router.POST(baseURL+"/async/transactions", wrapper.AsyncCreateTransaction)
	router.POST(baseURL+"/async/transactions/batch-capture", wrapper.AsyncBatchCaptureTransactions)
	router.POST(baseURL+"/async/transactions/:transaction_id/authorize", wrapper.AsyncAuthorizeTransaction)
	router.POST(baseURL+"/async/transactions/:transaction_id/capture", wrapper.AsyncCaptureTransaction)
	router.DELETE(baseURL+"/auth/sessions", wrapper.Logout)
	router.POST(baseURL+"/auth/sessions", wrapper.Login)
	router.PUT(baseURL+"/auth/sessions", wrapper.RefreshSession)
	router.GET(baseURL+"/buyers", wrapper.ListBuyers)
	router.POST(baseURL+"/buyers", wrapper.AddBuyer)
	router.GET(baseURL+"/buyers/payment-methods", wrapper.ListBuyerPaymentMethods)
	router.DELETE(baseURL+"/buyers/:buyer_id", wrapper.DeleteBuyer)
	router.GET(baseURL+"/buyers/:buyer_id", wrapper.GetBuyer)
	router.PUT(baseURL+"/buyers/:buyer_id", wrapper.UpdateBuyer)
	router.GET(baseURL+"/card-rules", wrapper.ListCardsRules)
	router.POST(baseURL+"/card-rules", wrapper.AddCardRule)
	router.DELETE(baseURL+"/card-rules/:card_rule_id", wrapper.DeleteCardRule)
	router.GET(baseURL+"/card-rules/:card_rule_id", wrapper.GetCardRule)
	router.PUT(baseURL+"/card-rules/:card_rule_id", wrapper.UpdateCardRule)
	router.GET(baseURL+"/merchants/main", wrapper.GetCurrentMerchant)
	router.GET(baseURL+"/payment-methods", wrapper.ListPaymentMethods)
	router.POST(baseURL+"/payment-methods", wrapper.StorePaymentMethod)
	router.DELETE(baseURL+"/payment-methods/:payment_method_id", wrapper.DeletePaymentMethod)
	router.GET(baseURL+"/payment-methods/:payment_method_id", wrapper.GetPaymentMethod)
	router.GET(baseURL+"/payment-options", wrapper.ListPaymentOptions)
	router.GET(baseURL+"/payment-service-definitions", wrapper.ListPaymentServiceDefinitions)
	router.GET(baseURL+"/payment-service-definitions/:payment_service_definition_id", wrapper.GetPaymentServiceDefinition)
	router.GET(baseURL+"/payment-services", wrapper.ListPaymentServices)
	router.POST(baseURL+"/payment-services", wrapper.AddPaymentService)
	router.DELETE(baseURL+"/payment-services/:payment_service_id", wrapper.DeletePaymentService)
	router.GET(baseURL+"/payment-services/:payment_service_id", wrapper.GetPaymentService)
	router.PUT(baseURL+"/payment-services/:payment_service_id", wrapper.UpdatePaymentService)
	router.GET(baseURL+"/transactions", wrapper.ListTransactions)
	router.POST(baseURL+"/transactions", wrapper.AuthorizeNewTransaction)
	router.GET(baseURL+"/transactions/approvals/:transaction_approval_token", wrapper.RedirectTransactionApproval)
	router.GET(baseURL+"/transactions/:transaction_id", wrapper.GetTransaction)
	router.GET(baseURL+"/transactions/:transaction_id/approve", wrapper.ApproveTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/authorize", wrapper.AuthorizeTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/capture", wrapper.CaptureTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/refund", wrapper.RefundTransaction)
	router.GET(baseURL+"/users/me", wrapper.GetCurrentUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/w8AAP//iPlj+CvBAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}

