// Package Openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package Openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for BuyerType.
const (
	BuyerTypeBuyer BuyerType = "buyer"
)

// Defines values for CardEnvironment.
const (
	CardEnvironmentDevelopment CardEnvironment = "development"

	CardEnvironmentProduction CardEnvironment = "production"

	CardEnvironmentStaging CardEnvironment = "staging"
)

// Defines values for CardMethod.
const (
	CardMethodCard CardMethod = "card"
)

// Defines values for CardStatus.
const (
	CardStatusProcessing CardStatus = "processing"

	CardStatusProcessingFailed CardStatus = "processing_failed"

	CardStatusStored CardStatus = "stored"

	CardStatusUsed CardStatus = "used"
)

// Defines values for CardType.
const (
	CardTypePaymentMethod CardType = "payment-method"
)

// Defines values for CardTokenizedMethod.
const (
	CardTokenizedMethodCard CardTokenizedMethod = "card"
)

// Defines values for CardTokenizedType.
const (
	CardTokenizedTypePaymentMethod CardTokenizedType = "payment-method"
)

// Defines values for CardDetailsScheme.
const (
	CardDetailsSchemeAmericanExpress CardDetailsScheme = "american-express"

	CardDetailsSchemeDinersClub CardDetailsScheme = "diners-club"

	CardDetailsSchemeDiscover CardDetailsScheme = "discover"

	CardDetailsSchemeElo CardDetailsScheme = "elo"

	CardDetailsSchemeHiper CardDetailsScheme = "hiper"

	CardDetailsSchemeHipercard CardDetailsScheme = "hipercard"

	CardDetailsSchemeJcb CardDetailsScheme = "jcb"

	CardDetailsSchemeMaestro CardDetailsScheme = "maestro"

	CardDetailsSchemeMastercard CardDetailsScheme = "mastercard"

	CardDetailsSchemeMir CardDetailsScheme = "mir"

	CardDetailsSchemeUnionpay CardDetailsScheme = "unionpay"

	CardDetailsSchemeVisa CardDetailsScheme = "visa"
)

// Defines values for CardRequestEnvironment.
const (
	CardRequestEnvironmentDevelopment CardRequestEnvironment = "development"

	CardRequestEnvironmentProduction CardRequestEnvironment = "production"

	CardRequestEnvironmentStaging CardRequestEnvironment = "staging"
)

// Defines values for CardRequestMethod.
const (
	CardRequestMethodCard CardRequestMethod = "card"
)

// Defines values for CardRuleEnvironment.
const (
	CardRuleEnvironmentDevelopment CardRuleEnvironment = "development"

	CardRuleEnvironmentProduction CardRuleEnvironment = "production"

	CardRuleEnvironmentStaging CardRuleEnvironment = "staging"
)

// Defines values for CardRuleInvalidRuleFallbackStrategy.
const (
	CardRuleInvalidRuleFallbackStrategyDecline CardRuleInvalidRuleFallbackStrategy = "decline"

	CardRuleInvalidRuleFallbackStrategySkip CardRuleInvalidRuleFallbackStrategy = "skip"

	CardRuleInvalidRuleFallbackStrategyUseAllProviders CardRuleInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleType.
const (
	CardRuleTypeCardRule CardRuleType = "card-rule"
)

// Defines values for CardRuleUnprocessableFallbackStrategy.
const (
	CardRuleUnprocessableFallbackStrategyDecline CardRuleUnprocessableFallbackStrategy = "decline"

	CardRuleUnprocessableFallbackStrategyUseAllProviders CardRuleUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleConditionKey.
const (
	CardRuleConditionKeyAmount CardRuleConditionKey = "amount"

	CardRuleConditionKeyCurrency CardRuleConditionKey = "currency"

	CardRuleConditionKeyScheme CardRuleConditionKey = "scheme"
)

// Defines values for CardRuleConditionMatch.
const (
	CardRuleConditionMatchNumber CardRuleConditionMatch = "number"

	CardRuleConditionMatchText CardRuleConditionMatch = "text"
)

// Defines values for CardRuleRequestEnvironment.
const (
	CardRuleRequestEnvironmentDevelopment CardRuleRequestEnvironment = "development"

	CardRuleRequestEnvironmentProduction CardRuleRequestEnvironment = "production"

	CardRuleRequestEnvironmentStaging CardRuleRequestEnvironment = "staging"
)

// Defines values for CardRuleRequestInvalidRuleFallbackStrategy.
const (
	CardRuleRequestInvalidRuleFallbackStrategyDecline CardRuleRequestInvalidRuleFallbackStrategy = "decline"

	CardRuleRequestInvalidRuleFallbackStrategySkip CardRuleRequestInvalidRuleFallbackStrategy = "skip"

	CardRuleRequestInvalidRuleFallbackStrategyUseAllProviders CardRuleRequestInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleRequestUnprocessableFallbackStrategy.
const (
	CardRuleRequestUnprocessableFallbackStrategyDecline CardRuleRequestUnprocessableFallbackStrategy = "decline"

	CardRuleRequestUnprocessableFallbackStrategyUseAllProviders CardRuleRequestUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleUpdateEnvironment.
const (
	CardRuleUpdateEnvironmentDevelopment CardRuleUpdateEnvironment = "development"

	CardRuleUpdateEnvironmentProduction CardRuleUpdateEnvironment = "production"

	CardRuleUpdateEnvironmentStaging CardRuleUpdateEnvironment = "staging"
)

// Defines values for CardRuleUpdateInvalidRuleFallbackStrategy.
const (
	CardRuleUpdateInvalidRuleFallbackStrategyDecline CardRuleUpdateInvalidRuleFallbackStrategy = "decline"

	CardRuleUpdateInvalidRuleFallbackStrategySkip CardRuleUpdateInvalidRuleFallbackStrategy = "skip"

	CardRuleUpdateInvalidRuleFallbackStrategyUseAllProviders CardRuleUpdateInvalidRuleFallbackStrategy = "use_all_providers"
)

// Defines values for CardRuleUpdateUnprocessableFallbackStrategy.
const (
	CardRuleUpdateUnprocessableFallbackStrategyDecline CardRuleUpdateUnprocessableFallbackStrategy = "decline"

	CardRuleUpdateUnprocessableFallbackStrategyUseAllProviders CardRuleUpdateUnprocessableFallbackStrategy = "use_all_providers"
)

// Defines values for Error400BadRequestCode.
const (
	Error400BadRequestCodeBadRequest Error400BadRequestCode = "bad_request"
)

// Defines values for Error400BadRequestStatus.
const (
	Error400BadRequestStatusN00 Error400BadRequestStatus = 400
)

// Defines values for Error400BadRequestType.
const (
	Error400BadRequestTypeError Error400BadRequestType = "error"
)

// Defines values for Error401UnauthorizedCode.
const (
	Error401UnauthorizedCodeUnauthorized Error401UnauthorizedCode = "unauthorized"
)

// Defines values for Error401UnauthorizedMessage.
const (
	Error401UnauthorizedMessageNoValidAPIAuthenticationFound Error401UnauthorizedMessage = "No valid API authentication found"
)

// Defines values for Error401UnauthorizedStatus.
const (
	Error401UnauthorizedStatusN01 Error401UnauthorizedStatus = 401
)

// Defines values for Error401UnauthorizedType.
const (
	Error401UnauthorizedTypeError Error401UnauthorizedType = "error"
)

// Defines values for Error404NotFoundCode.
const (
	Error404NotFoundCodeNotFound Error404NotFoundCode = "not_found"
)

// Defines values for Error404NotFoundMessage.
const (
	Error404NotFoundMessageTheResourceCouldNotBeFound Error404NotFoundMessage = "The resource could not be found"
)

// Defines values for Error404NotFoundStatus.
const (
	Error404NotFoundStatusN04 Error404NotFoundStatus = 404
)

// Defines values for Error404NotFoundType.
const (
	Error404NotFoundTypeError Error404NotFoundType = "error"
)

// Defines values for Error409DuplicateRecordCode.
const (
	Error409DuplicateRecordCodeDuplicateRecord Error409DuplicateRecordCode = "duplicate_record"
)

// Defines values for Error409DuplicateRecordStatus.
const (
	Error409DuplicateRecordStatusN09 Error409DuplicateRecordStatus = 409
)

// Defines values for Error409DuplicateRecordType.
const (
	Error409DuplicateRecordTypeError Error409DuplicateRecordType = "error"
)

// Defines values for ErrorDetailLocation.
const (
	ErrorDetailLocationBody ErrorDetailLocation = "body"

	ErrorDetailLocationHeader ErrorDetailLocation = "header"

	ErrorDetailLocationPath ErrorDetailLocation = "path"

	ErrorDetailLocationQuery ErrorDetailLocation = "query"
)

// Defines values for ErrorGenericType.
const (
	ErrorGenericTypeError ErrorGenericType = "error"
)

// Defines values for PaymentMethodDetailsScheme.
const (
	PaymentMethodDetailsSchemeAmericanExpress PaymentMethodDetailsScheme = "american-express"

	PaymentMethodDetailsSchemeDinersClub PaymentMethodDetailsScheme = "diners-club"

	PaymentMethodDetailsSchemeDiscover PaymentMethodDetailsScheme = "discover"

	PaymentMethodDetailsSchemeElo PaymentMethodDetailsScheme = "elo"

	PaymentMethodDetailsSchemeHiper PaymentMethodDetailsScheme = "hiper"

	PaymentMethodDetailsSchemeHipercard PaymentMethodDetailsScheme = "hipercard"

	PaymentMethodDetailsSchemeJcb PaymentMethodDetailsScheme = "jcb"

	PaymentMethodDetailsSchemeMaestro PaymentMethodDetailsScheme = "maestro"

	PaymentMethodDetailsSchemeMastercard PaymentMethodDetailsScheme = "mastercard"

	PaymentMethodDetailsSchemeMir PaymentMethodDetailsScheme = "mir"

	PaymentMethodDetailsSchemeUnionpay PaymentMethodDetailsScheme = "unionpay"

	PaymentMethodDetailsSchemeVisa PaymentMethodDetailsScheme = "visa"
)

// Defines values for PaymentMethodMethod.
const (
	PaymentMethodMethodCard PaymentMethodMethod = "card"

	PaymentMethodMethodPaypal PaymentMethodMethod = "paypal"
)

// Defines values for PaymentMethodStatus.
const (
	PaymentMethodStatusBuyerApprovalDeclined PaymentMethodStatus = "buyer_approval_declined"

	PaymentMethodStatusBuyerApprovalPending PaymentMethodStatus = "buyer_approval_pending"

	PaymentMethodStatusBuyerApprovalTimedout PaymentMethodStatus = "buyer_approval_timedout"

	PaymentMethodStatusBuyerApproved PaymentMethodStatus = "buyer_approved"

	PaymentMethodStatusProcessing PaymentMethodStatus = "processing"

	PaymentMethodStatusProcessingFailed PaymentMethodStatus = "processing_failed"

	PaymentMethodStatusStored PaymentMethodStatus = "stored"

	PaymentMethodStatusUsed PaymentMethodStatus = "used"
)

// Defines values for PaymentMethodType.
const (
	PaymentMethodTypePaymentMethod PaymentMethodType = "payment-method"
)

// Defines values for PaymentOptionMethod.
const (
	PaymentOptionMethodCard PaymentOptionMethod = "card"

	PaymentOptionMethodPaypal PaymentOptionMethod = "paypal"
)

// Defines values for PaymentOptionType.
const (
	PaymentOptionTypePaymentOption PaymentOptionType = "payment-option"
)

// Defines values for PaymentServiceCredentialsMode.
const (
	PaymentServiceCredentialsModeLive PaymentServiceCredentialsMode = "live"

	PaymentServiceCredentialsModeSandbox PaymentServiceCredentialsMode = "sandbox"
)

// Defines values for PaymentServiceEnvironments.
const (
	PaymentServiceEnvironmentsDevelopment PaymentServiceEnvironments = "development"

	PaymentServiceEnvironmentsProduction PaymentServiceEnvironments = "production"

	PaymentServiceEnvironmentsStaging PaymentServiceEnvironments = "staging"
)

// Defines values for PaymentServiceMethod.
const (
	PaymentServiceMethodCard PaymentServiceMethod = "card"

	PaymentServiceMethodPaypal PaymentServiceMethod = "paypal"
)

// Defines values for PaymentServiceStatus.
const (
	PaymentServiceStatusCreated PaymentServiceStatus = "created"

	PaymentServiceStatusFailed PaymentServiceStatus = "failed"

	PaymentServiceStatusPending PaymentServiceStatus = "pending"
)

// Defines values for PaymentServiceType.
const (
	PaymentServiceTypePaymentService PaymentServiceType = "payment-service"
)

// Defines values for PaymentServiceDefinitionMethod.
const (
	PaymentServiceDefinitionMethodCard PaymentServiceDefinitionMethod = "card"

	PaymentServiceDefinitionMethodPaypal PaymentServiceDefinitionMethod = "paypal"
)

// Defines values for PaymentServiceUpdateCredentialsMode.
const (
	PaymentServiceUpdateCredentialsModeLive PaymentServiceUpdateCredentialsMode = "live"

	PaymentServiceUpdateCredentialsModeSandbox PaymentServiceUpdateCredentialsMode = "sandbox"
)

// Defines values for PaymentServiceUpdateEnvironments.
const (
	PaymentServiceUpdateEnvironmentsDevelopment PaymentServiceUpdateEnvironments = "development"

	PaymentServiceUpdateEnvironmentsProduction PaymentServiceUpdateEnvironments = "production"

	PaymentServiceUpdateEnvironmentsStaging PaymentServiceUpdateEnvironments = "staging"
)

// Defines values for TransactionEnvironment.
const (
	TransactionEnvironmentDevelopment TransactionEnvironment = "development"

	TransactionEnvironmentProduction TransactionEnvironment = "production"

	TransactionEnvironmentStaging TransactionEnvironment = "staging"
)

// Defines values for TransactionStatus.
const (
	TransactionStatusAuthorizationDeclined TransactionStatus = "authorization_declined"

	TransactionStatusAuthorizationExpired TransactionStatus = "authorization_expired"

	TransactionStatusAuthorizationPending TransactionStatus = "authorization_pending"

	TransactionStatusAuthorizationVoided TransactionStatus = "authorization_voided"

	TransactionStatusAuthorized TransactionStatus = "authorized"

	TransactionStatusBuyerApprovalDeclined TransactionStatus = "buyer_approval_declined"

	TransactionStatusBuyerApprovalPending TransactionStatus = "buyer_approval_pending"

	TransactionStatusBuyerApprovalTimedout TransactionStatus = "buyer_approval_timedout"

	TransactionStatusBuyerApproved TransactionStatus = "buyer_approved"

	TransactionStatusCaptureDeclined TransactionStatus = "capture_declined"

	TransactionStatusCapturePending TransactionStatus = "capture_pending"

	TransactionStatusCaptured TransactionStatus = "captured"

	TransactionStatusProcessing TransactionStatus = "processing"

	TransactionStatusProcessingFailed TransactionStatus = "processing_failed"

	TransactionStatusRefunded TransactionStatus = "refunded"
)

// Defines values for TransactionType.
const (
	TransactionTypeTransaction TransactionType = "transaction"
)

// Defines values for TransactionPaymentMethodRequestMethod.
const (
	TransactionPaymentMethodRequestMethodCard TransactionPaymentMethodRequestMethod = "card"

	TransactionPaymentMethodRequestMethodPaypal TransactionPaymentMethodRequestMethod = "paypal"

	TransactionPaymentMethodRequestMethodToken TransactionPaymentMethodRequestMethod = "token"
)

// Defines values for TransactionRequestEnvironment.
const (
	TransactionRequestEnvironmentDevelopment TransactionRequestEnvironment = "development"

	TransactionRequestEnvironmentProduction TransactionRequestEnvironment = "production"

	TransactionRequestEnvironmentStaging TransactionRequestEnvironment = "staging"
)

// Defines values for TransactionRequestIntent.
const (
	TransactionRequestIntentApprove TransactionRequestIntent = "approve"

	TransactionRequestIntentAuthorize TransactionRequestIntent = "authorize"

	TransactionRequestIntentCapture TransactionRequestIntent = "capture"
)

// Buyer defines model for Buyer.
type Buyer struct {

	// The date and time
	// when this buyer was created in our system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
	DisplayName *string `json:"display_name"`

	// An external identifier that can be used to match the buyer against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique Gr4vy ID for this buyer.
	Id *string `json:"id,omitempty"`

	// The type of this resource. Is always `buyer`.
	Type *BuyerType `json:"type,omitempty"`

	// The date and time
	// when this buyer was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The type of this resource. Is always `buyer`.
type BuyerType string

// A request to create a buyer.
type BuyerRequest struct {

	// A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
	DisplayName *string `json:"display_name"`

	// An external identifier that can be used to match the buyer against your own records. This value needs to be unique for all buyers.
	ExternalIdentifier *string `json:"external_identifier"`
}

// BuyerUpdate defines model for BuyerUpdate.
type BuyerUpdate struct {
	// Embedded struct due to allOf(#/components/schemas/BuyerRequest)
	BuyerRequest `yaml:",inline"`
}

// A list of buyers.
type Buyers struct {

	// A list of buyers.
	Items *[]Buyer `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A stored card.
type Card struct {

	// The optional buyer for which this payment method has been stored.
	Buyer *struct {
		// Embedded struct due to allOf(#/components/schemas/Buyer)
		Buyer `yaml:",inline"`
	} `json:"buyer"`

	// The date and time when this payment method was first created in our
	// system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Additional details about a stored card.
	Details *CardDetails `json:"details,omitempty"`

	// The environment this payment method has been stored for. This will be null
	// of the payment method was not stored.
	Environment *CardEnvironment `json:"environment"`

	// An external identifier that can be used to match the payment method
	// against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// `card`.
	Method *CardMethod `json:"method,omitempty"`

	// The state of the card tokenization.
	Status *CardStatus `json:"status,omitempty"`

	// `payment-method`.
	Type *CardType `json:"type,omitempty"`

	// The date and time when this payment method was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment this payment method has been stored for. This will be null
// of the payment method was not stored.
type CardEnvironment string

// `card`.
type CardMethod string

// The state of the card tokenization.
type CardStatus string

// `payment-method`.
type CardType string

// A mini format version of the card.
type CardTokenized struct {

	// Additional details about a stored card.
	Details *CardDetails `json:"details,omitempty"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// `card`.
	Method *CardTokenizedMethod `json:"method,omitempty"`

	// `payment-method`.
	Type *CardTokenizedType `json:"type,omitempty"`
}

// `card`.
type CardTokenizedMethod string

// `payment-method`.
type CardTokenizedType string

// Additional details about a stored card.
type CardDetails struct {

	// The expiration date for a card.
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// The type of the card.
	Scheme *CardDetailsScheme `json:"scheme,omitempty"`

	// The last 4 digits of the card number.
	Suffix *string `json:"suffix,omitempty"`
}

// The type of the card.
type CardDetailsScheme string

// Card details to use in a transaction or to register a new payment method.
type CardRequest struct {

	// The `external_identifier` of the buyer to associate this payment method
	// to. If this field is provided then the `buyer_id` field
	// needs to be unset.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// The ID of the buyer to associate this payment method to. If this field is
	// provided then the `buyer_external_identifier` field needs to be unset.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Defines the environment to store this card for. Setting this to
	// anything other than `production` will force Gr4vy to use the payment
	// services configured for that environment.
	Environment *CardRequestEnvironment `json:"environment,omitempty"`

	// The expiration date of the card, formatted `MM/YY`.
	ExpirationDate string `json:"expiration_date"`

	// An external identifier that can be used to match the card against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// `card`.
	Method CardRequestMethod `json:"method"`

	// The 15-16 digit number for this card as it can be found on the
	// front of the card.
	Number string `json:"number"`

	// The 3 or 4 digit security code often found on the card. This often
	// referred to as the CVV or CVD.
	SecurityCode string `json:"security_code"`
}

// Defines the environment to store this card for. Setting this to
// anything other than `production` will force Gr4vy to use the payment
// services configured for that environment.
type CardRequestEnvironment string

// `card`.
type CardRequestMethod string

// A card rule that defines a custom payment provider to use for a card
// transaction. Multiple rules can exists at any time and they are processed by
// priority.
type CardRule struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions *[]CardRuleCondition `json:"conditions,omitempty"`

	// The date and time when this rule was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleEnvironment `json:"environment,omitempty"`

	// The ID of the rule.
	Id *string `json:"id,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds *[]string `json:"payment_service_ids,omitempty"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first.
	Position *float32 `json:"position,omitempty"`

	// `card-rule`.
	Type *CardRuleType `json:"type,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`

	// The date and time when this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleInvalidRuleFallbackStrategy string

// `card-rule`.
type CardRuleType string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleUnprocessableFallbackStrategy string

// Generic card rule condition.
type CardRuleCondition struct {

	// The transaction field to filter by.
	Key CardRuleConditionKey `json:"key"`

	// The type of match made for this rule.
	Match CardRuleConditionMatch `json:"match"`

	// The comparison to make to `value` property.
	Operator string `json:"operator"`

	// The values to compare the `key` to.
	Value string `json:"value"`
}

// The transaction field to filter by.
type CardRuleConditionKey string

// The type of match made for this rule.
type CardRuleConditionMatch string

// Creates a new rule for a card transactions.
type CardRuleRequest struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions []CardRule `json:"conditions"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleRequestEnvironment `json:"environment,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleRequestInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds []string `json:"payment_service_ids"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first. When a rule is inserted at a position, any rules with
	// the the same value or higher are down a position accordingly. When left
	// out, the rule is inserted at the end of the list.
	Position *float32 `json:"position,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleRequestUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleRequestEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleRequestInvalidRuleFallbackStrategy string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleRequestUnprocessableFallbackStrategy string

// Updates a rule for a card transactions.
type CardRuleUpdate struct {

	// Whether this rule is currently in use. Rules can be deactivated to allow
	// for them to be kept around and re-activated at a later date.
	Active *bool `json:"active,omitempty"`

	// One or more conditions that apply for this rule. Each condition
	// needs to match for this rule to go into effect.
	Conditions *[]CardRule `json:"conditions,omitempty"`

	// The environment to use this rule in. This rule will only be used
	// for transactions created in that environment.
	Environment *CardRuleUpdateEnvironment `json:"environment,omitempty"`

	// Defines what strategy to use when this rule is not valid. This can happen
	// when the rule has triggered for a certain transaction but none of the
	// listed payment services are eligible to process that transaction currency.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `skip` - Skip this rule and instead move on to the next highest priority
	// rule.
	// * `decline` - Decline the transaction.
	InvalidRuleFallbackStrategy *CardRuleUpdateInvalidRuleFallbackStrategy `json:"invalid_rule_fallback_strategy,omitempty"`

	// A list of IDs for the payment services to use, in order of priority.
	// The payment services all need to process cards.
	PaymentServiceIds *[]string `json:"payment_service_ids,omitempty"`

	// The numeric rank of a rule. Rules with a lower position value
	// are processed first. When a rule is inserted at a position, any rules with
	// the the same value or higher are down a position accordingly.
	Position *float32 `json:"position,omitempty"`

	// Defines what strategy to use when all of the payment services defined in
	// this rule declined or otherwise were not able to process the card.
	//
	// * `use_all_providers` - Try all payment services enabled for this currency in
	// order of priority, even if they are not listed in this rule. This is the
	// default behaviour for a rule.
	// * `decline` - Decline the transaction.
	UnprocessableFallbackStrategy *CardRuleUpdateUnprocessableFallbackStrategy `json:"unprocessable_fallback_strategy,omitempty"`
}

// The environment to use this rule in. This rule will only be used
// for transactions created in that environment.
type CardRuleUpdateEnvironment string

// Defines what strategy to use when this rule is not valid. This can happen
// when the rule has triggered for a certain transaction but none of the
// listed payment services are eligible to process that transaction currency.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `skip` - Skip this rule and instead move on to the next highest priority
// rule.
// * `decline` - Decline the transaction.
type CardRuleUpdateInvalidRuleFallbackStrategy string

// Defines what strategy to use when all of the payment services defined in
// this rule declined or otherwise were not able to process the card.
//
// * `use_all_providers` - Try all payment services enabled for this currency in
// order of priority, even if they are not listed in this rule. This is the
// default behaviour for a rule.
// * `decline` - Decline the transaction.
type CardRuleUpdateUnprocessableFallbackStrategy string

// A list of card rules.
type CardRules struct {

	// A list of card rules.
	Items *[]CardRule `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// Bad Request (HTTP 400).
type Error400BadRequest struct {

	// `bad_request`.
	Code *Error400BadRequestCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Describes the fields that are missing or incorrectly formatted in the API
	// request.
	Message *string `json:"message,omitempty"`

	// `400`.
	Status *Error400BadRequestStatus `json:"status,omitempty"`

	// `error`.
	Type *Error400BadRequestType `json:"type,omitempty"`
}

// `bad_request`.
type Error400BadRequestCode string

// `400`.
type Error400BadRequestStatus int

// `error`.
type Error400BadRequestType string

// Unauthorized Error (HTTP 401).
type Error401Unauthorized struct {

	// `unauthorized`.
	Code *Error401UnauthorizedCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// No valid API authentication found.
	Message *Error401UnauthorizedMessage `json:"message,omitempty"`

	// `401`.
	Status *Error401UnauthorizedStatus `json:"status,omitempty"`

	// `error`.
	Type *Error401UnauthorizedType `json:"type,omitempty"`
}

// `unauthorized`.
type Error401UnauthorizedCode string

// No valid API authentication found.
type Error401UnauthorizedMessage string

// `401`.
type Error401UnauthorizedStatus int

// `error`.
type Error401UnauthorizedType string

// Not Found Error (HTTP 404).
type Error404NotFound struct {

	// `not_found`.
	Code *Error404NotFoundCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// The resource could not be found.
	Message *Error404NotFoundMessage `json:"message,omitempty"`

	// `404`.
	Status *Error404NotFoundStatus `json:"status,omitempty"`

	// `error`.
	Type *Error404NotFoundType `json:"type,omitempty"`
}

// `not_found`.
type Error404NotFoundCode string

// The resource could not be found.
type Error404NotFoundMessage string

// `404`.
type Error404NotFoundStatus int

// `error`.
type Error404NotFoundType string

// Duplicate Record Error (HTTP 409).
type Error409DuplicateRecord struct {

	// `duplicate_record`.
	Code *Error409DuplicateRecordCode `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Further details on the field that triggered the error.
	Message *string `json:"message,omitempty"`

	// `409`.
	Status *Error409DuplicateRecordStatus `json:"status,omitempty"`

	// `error`.
	Type *Error409DuplicateRecordType `json:"type,omitempty"`
}

// `duplicate_record`.
type Error409DuplicateRecordCode string

// `409`.
type Error409DuplicateRecordStatus int

// `error`.
type Error409DuplicateRecordType string

// Additional detail about the part of a request body that caused an issue.
type ErrorDetail struct {

	// The location where the error caused an issue.
	Location *ErrorDetailLocation `json:"location,omitempty"`

	// A human readable message for this error detail.
	Message *string `json:"message,omitempty"`

	// The exact item for which the validation did not succeed. This is a JSON
	// pointer for request bodies, while for query, path, and header parameters
	// it is the name of the parameter.
	Pointer *string `json:"pointer,omitempty"`

	// A unique identifier for the type of error that occurred.
	Type *string `json:"type,omitempty"`
}

// The location where the error caused an issue.
type ErrorDetailLocation string

// A generic client error.
type ErrorGeneric struct {

	// A custom code to further describe the type of error being returned. This code provides further specification within the HTTP `status` code and can be used by a program to define logic based on the error.
	Code *string `json:"code,omitempty"`

	// A list of detail objects that further clarify the reason for the error.
	// Not every error supports more detail.
	Details *[]ErrorDetail `json:"details,omitempty"`

	// A human readable message that describes the error. The content of this field should not be used to determine any business logic.
	Message *string `json:"message,omitempty"`

	// The HTTP status code of this error.
	Status *int32 `json:"status,omitempty"`

	// The type of this object. This is always `error`.
	Type *ErrorGenericType `json:"type,omitempty"`
}

// The type of this object. This is always `error`.
type ErrorGenericType string

// A generic payment method.
type PaymentMethod struct {

	// The optional buyer for which this payment method has been stored.
	Buyer *struct {
		// Embedded struct due to allOf(#/components/schemas/Buyer)
		Buyer `yaml:",inline"`
	} `json:"buyer"`

	// The date and time when this payment method was first created in our
	// system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Additional details about a payment method.
	Details *struct {

		// The optional URL that the buyer needs to be redirected to to further authorize the payment method.
		ApprovalUrl *string `json:"approval_url"`

		// The email address associated to the payment method.
		EmailAddress *string `json:"email_address"`

		// The expiration date for a card.
		ExpirationDate *string `json:"expiration_date,omitempty"`

		// Partial number details for a stored card, hiding all but the last few
		// numbers.
		Number *string `json:"number,omitempty"`

		// The type of the card.
		Scheme *PaymentMethodDetailsScheme `json:"scheme,omitempty"`
	} `json:"details,omitempty"`

	// An external identifier that can be used to match the payment method
	// against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique ID of the payment method.
	Id *string `json:"id,omitempty"`

	// The type of this payment method.
	Method *PaymentMethodMethod `json:"method,omitempty"`

	// The state of the payment method.
	Status *PaymentMethodStatus `json:"status,omitempty"`

	// `payment-method`.
	Type *PaymentMethodType `json:"type,omitempty"`

	// The date and time when this payment method was last updated in our system.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The type of the card.
type PaymentMethodDetailsScheme string

// The type of this payment method.
type PaymentMethodMethod string

// The state of the payment method.
type PaymentMethodStatus string

// `payment-method`.
type PaymentMethodType string

// A list of stored payment methods.
type PaymentMethods struct {

	// A list of stored payment methods.
	Items *[]Card `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A list of stored payment methods in token format.
type PaymentMethodsTokenized struct {

	// A list of stored payment methods in token format.
	Items *[]CardTokenized `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// An available payment option for a locale.
type PaymentOption struct {

	// The type of payment method that is available.
	Method *PaymentOptionMethod `json:"method,omitempty"`

	// `payment-option`.
	Type *PaymentOptionType `json:"type,omitempty"`
}

// The type of payment method that is available.
type PaymentOptionMethod string

// `payment-option`.
type PaymentOptionType string

// A list of payment options.
type PaymentOptions struct {
	Items *[]PaymentOption `json:"items,omitempty"`
}

// An active, configured payment service.
type PaymentService struct {

	// A list of countries for which this service is enabled, in ISO two-letter
	// code format.
	AcceptedCountries *[]string `json:"accepted_countries,omitempty"`

	// A list of currencies for which this service is enabled, in ISO 4217
	// three-letter code format.
	AcceptedCurrencies *[]string `json:"accepted_currencies,omitempty"`

	// Defines if this service is currently active or not.
	Active *bool `json:"active,omitempty"`

	// The date and time when this service was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Defines if the credentials are intended for the service's live API or
	// sandbox/test API.
	CredentialsMode *PaymentServiceCredentialsMode `json:"credentials_mode,omitempty"`

	// The custom name set for this service.
	DisplayName *string `json:"display_name,omitempty"`

	// Determines the Gr4vy environments in which this service should be
	// available. This can be used in combination with the `environment`
	// parameters in the payment method and transaction APIs to route
	// transactions through this service.
	Environments *[]PaymentServiceEnvironments `json:"environments,omitempty"`

	// The ID of this payment service.
	Id *string `json:"id,omitempty"`

	// Defines the ID of the payment method that this service handles.
	Method *PaymentServiceMethod `json:"method,omitempty"`

	// The ID of the payment service definition used to create this service.
	PaymentServiceDefinitionId *string `json:"payment_service_definition_id,omitempty"`

	// The numeric rank of a payment service. Payment services with a lower
	// position value are processed first.
	Position *float32 `json:"position,omitempty"`

	// The current status of this service. This will start off as pending, move
	// to created, and might eventually move to an error status if and when the
	// credentials are no longer valid.
	Status *PaymentServiceStatus `json:"status,omitempty"`

	// The type of this resource.
	Type *PaymentServiceType `json:"type,omitempty"`

	// The date and time when this service was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Defines if the credentials are intended for the service's live API or
// sandbox/test API.
type PaymentServiceCredentialsMode string

// PaymentServiceEnvironments defines model for PaymentService.Environments.
type PaymentServiceEnvironments string

// Defines the ID of the payment method that this service handles.
type PaymentServiceMethod string

// The current status of this service. This will start off as pending, move
// to created, and might eventually move to an error status if and when the
// credentials are no longer valid.
type PaymentServiceStatus string

// The type of this resource.
type PaymentServiceType string

// An available payment service that can be configured.
type PaymentServiceDefinition struct {

	// The display name of this service.
	DisplayName *string `json:"display_name,omitempty"`

	// A list of fields that need to be submitted when activating the payment. service.
	Fields *[]struct {

		// The name to display for a field in the dashboard.
		DisplayName *string `json:"display_name,omitempty"`

		// Defines the type of input that needs to be rendered for this field.
		Format *string `json:"format,omitempty"`

		// The key of a field that needs to be submitted.
		Key *string `json:"key,omitempty"`

		// Defines if this field is required when the service is created.
		Required *bool `json:"required,omitempty"`
	} `json:"fields,omitempty"`

	// The ID of the payment service. This is the underlying provider followed by a dash followed by the payment method ID.
	Id *string `json:"id,omitempty"`

	// The ID of the payment method that this services handles.
	Method *PaymentServiceDefinitionMethod `json:"method,omitempty"`

	// A list of two-letter ISO country codes that this service supports.
	SupportedCountries *[]string `json:"supported_countries,omitempty"`

	// A list of three-letter ISO currency codes that this service supports.
	SupportedCurrencies *[]string `json:"supported_currencies,omitempty"`

	// `payment-service-definition`.
	Type *string `json:"type,omitempty"`
}

// The ID of the payment method that this services handles.
type PaymentServiceDefinitionMethod string

// A list of available payment services definitions.
type PaymentServiceDefinitions struct {
	Items *[]PaymentServiceDefinition `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// PaymentServiceRequest defines model for PaymentServiceRequest.
type PaymentServiceRequest struct {
	// Embedded struct due to allOf(#/components/schemas/PaymentServiceUpdate)
	PaymentServiceUpdate `yaml:",inline"`
	// Embedded fields due to inline allOf schema

	// The ID of the payment service to use.
	PaymentServiceDefinitionId *string `json:"payment_service_definition_id,omitempty"`
}

// Request body for updating an active payment service.
type PaymentServiceUpdate struct {

	// A list of countries that this payment service needs to support in ISO two-letter code format.
	AcceptedCountries *[]string `json:"accepted_countries,omitempty"`

	// A list of currencies that this payment service needs to support in ISO 4217 three-letter code format.
	AcceptedCurrencies *[]string `json:"accepted_currencies,omitempty"`

	// Defines if this service is currently active or not.
	Active *bool `json:"active,omitempty"`

	// Defines if the credentials are intended for the service's live API or
	// sandbox/test API.
	CredentialsMode *PaymentServiceUpdateCredentialsMode `json:"credentials_mode,omitempty"`

	// A custom name for the payment service. This will be shown in the Admin UI.
	DisplayName *string `json:"display_name,omitempty"`

	// Determines the Gr4vy environments in which this service should be
	// available. This can be used in combination with the `environment`
	// parameters in the payment method and transaction APIs to route
	// transactions through this service.
	Environments *[]PaymentServiceUpdateEnvironments `json:"environments,omitempty"`

	// A list of fields, each containing a key-value pair for each field defined by the definition for this payment service e.g. for stripe-card `secret_key` is required and so must be sent with in this field.
	Fields *[]struct {

		// The key of the field to set a value for.
		Key string `json:"key"`

		// The value of a field to set.
		Value string `json:"value"`
	} `json:"fields,omitempty"`

	// The numeric rank of a payment service. Payment services with a lower
	// position value are processed first. When a payment services is inserted at
	// a position, any payment services with the the same value or higher are
	// shifted down a position accordingly. When left out, the payment service is
	// inserted at the end of the list.
	Position *float32 `json:"position,omitempty"`
}

// Defines if the credentials are intended for the service's live API or
// sandbox/test API.
type PaymentServiceUpdateCredentialsMode string

// PaymentServiceUpdateEnvironments defines model for PaymentServiceUpdate.Environments.
type PaymentServiceUpdateEnvironments string

// A list of active, configured payment services.
type PaymentServices struct {
	Items *[]PaymentService `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// A transaction record.
type Transaction struct {

	// The currency amount captured by this transaction.
	Amount *float32 `json:"amount,omitempty"`

	// The date and time when this transaction was created in our system.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The currency code for this transaction.
	Currency *string `json:"currency,omitempty"`

	// The environment this transaction has been created in.
	Environment *TransactionEnvironment `json:"environment,omitempty"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The unique identifier for this transaction.
	Id *string `json:"id,omitempty"`

	// A generic payment method.
	PaymentMethod *PaymentMethod `json:"payment_method,omitempty"`

	// An active, configured payment service.
	PaymentService *PaymentService `json:"payment_service,omitempty"`

	// The status of the transaction being processed. This is different from the
	// `status` field in that it represents the status of the transaction at the
	// payment processor, not the status of the transaction created in Gr4vy.
	Status *TransactionStatus `json:"status,omitempty"`

	// The type of this resource. Is always `transaction`.
	Type *TransactionType `json:"type,omitempty"`

	// Defines when the transaction was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The environment this transaction has been created in.
type TransactionEnvironment string

// The status of the transaction being processed. This is different from the
// `status` field in that it represents the status of the transaction at the
// payment processor, not the status of the transaction created in Gr4vy.
type TransactionStatus string

// The type of this resource. Is always `transaction`.
type TransactionType string

// A request to capture a transaction.
type TransactionCaptureRequest struct {

	// The (partial) amount to capture.
	//
	// When left blank, this will capture the entire amount.
	Amount float32 `json:"amount"`

	// A supported ISO-4217 currency code.
	Currency string `json:"currency"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier,omitempty"`
}

// Payment method details to use in a transaction or to register
// a new payment method.
type TransactionPaymentMethodRequest struct {

	// The `external_identifier` of the buyer to associate this payment method
	// to. If this field is provided then the `buyer_id` field
	// needs to be unset.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// The ID of the buyer to associate this payment method to. If this field is
	// provided then the `buyer_external_identifier` field needs to be unset.
	BuyerId *string `json:"buyer_id,omitempty"`

	// The expiration date of the card, formatted `MM/YY`. If a card has been
	// previously stored with us this value is optional.
	//
	// If the `number` of this card represents a tokenized card, then this value
	// is ignored.
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// An external identifier that can be used to match the card against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// The method to use for this request.
	Method TransactionPaymentMethodRequestMethod `json:"method"`

	// The 15-16 digit number for this credit card as it can be found on the
	// front of the card.
	//
	// If a card has been stored with us previously, this number will represent
	// the unique tokenized card ID provided via our API.
	Number *string `json:"number,omitempty"`

	// The redirect URL to redirect a buyer to after they have authorized their
	// transaction or payment method. This only applies to payment methods that
	// require buyer approval.
	RedirectUrl *string `json:"redirect_url,omitempty"`

	// The 3 or 4 digit security code often found on the card. This often
	// referred to as the CVV or CVD.
	//
	// If the `number` of this card represents a tokenized card, then this value
	// is ignored.
	SecurityCode *string `json:"security_code,omitempty"`

	// A Gr4vy token that represents a previously tokenized payment method.
	// This token can represent any type of payment method.
	Token *string `json:"token,omitempty"`
}

// The method to use for this request.
type TransactionPaymentMethodRequestMethod string

// A request to create a transaction.
type TransactionRequest struct {

	// The monetary amount to create an authorization for, in the smallest
	// currency unit for the given currency, for example `1299` cents to create
	// an authorization for `$12.99`.
	//
	// For BitCoin, this value will be a decimal point number, for example
	// `0.0039`.
	Amount float32 `json:"amount"`

	// A supported ISO-4217 currency code.
	Currency string `json:"currency"`

	// Defines the environment to create this transaction in. Setting this to
	// anything other than `production` will force Gr4vy to use the payment
	// a service configured for that environment.
	Environment *TransactionRequestEnvironment `json:"environment,omitempty"`

	// An external identifier that can be used to match the transaction against your own records.
	ExternalIdentifier *string `json:"external_identifier"`

	// Defines the intent of this API call. This determines the desired initial
	// state of the transaction.
	//
	// * `approve` - Captures approval for the transaction from the user but does
	// not authorize it. This is only available to payment methods that require
	// explicit approval, like PayPal.
	// * `authorize` - (Default) Optionally approves and then authorizes a
	// transaction but does not capture the funds.
	// * `capture` - Optionally approves and then authorizes and captures the
	// funds of the transaction.
	Intent *TransactionRequestIntent `json:"intent,omitempty"`

	// Payment method details to use in a transaction or to register
	// a new payment method.
	PaymentMethod TransactionPaymentMethodRequest `json:"payment_method"`

	// Whether or not to also try and store the payment method with us so that
	// it can be used again for future use. This is only supported for payment
	// methods that support this feature.
	Store *bool `json:"store,omitempty"`
}

// Defines the environment to create this transaction in. Setting this to
// anything other than `production` will force Gr4vy to use the payment
// a service configured for that environment.
type TransactionRequestEnvironment string

// Defines the intent of this API call. This determines the desired initial
// state of the transaction.
//
// * `approve` - Captures approval for the transaction from the user but does
// not authorize it. This is only available to payment methods that require
// explicit approval, like PayPal.
// * `authorize` - (Default) Optionally approves and then authorizes a
// transaction but does not capture the funds.
// * `capture` - Optionally approves and then authorizes and captures the
// funds of the transaction.
type TransactionRequestIntent string

// A list of transactions.
type Transactions struct {

	// A list of transactions.
	Items *[]Transaction `json:"items,omitempty"`

	// The limit applied to request. This represents the number of items that are at
	// maximum returned by this request.
	Limit *int32 `json:"limit,omitempty"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	NextCursor *string `json:"next_cursor"`

	// The cursor that represents the next page of results. Use the `cursor` query
	// parameter to fetch this page of items.
	PreviousCursor *string `json:"previous_cursor"`
}

// ListBuyersParams defines parameters for ListBuyers.
type ListBuyersParams struct {

	// Filters the results to only the buyers for which the `display_name` or
	// `external_identifier` matches this value. This field allows for a partial
	// match, matching any buyer for which either of the fields partially or
	// completely matches.
	Search *string `json:"search,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// AddBuyerJSONBody defines parameters for AddBuyer.
type AddBuyerJSONBody BuyerRequest

// ListBuyerPaymentMethodsParams defines parameters for ListBuyerPaymentMethods.
type ListBuyerPaymentMethodsParams struct {

	// Filters the results to only the items for which the `buyer` has an
	// `id` that matches this value.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `external_identifier` that matches this value.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// Filters the results to only the items which support this country code. A
	// country is formatted as 2-letter ISO country code.
	Country *string `json:"country,omitempty"`

	// Filters the results to only the items which support this currency code. A
	// currency is formatted as 3-letter ISO currency code.
	Currency *string `json:"currency,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListBuyerPaymentMethodsParamsEnvironment `json:"environment,omitempty"`
}

// ListBuyerPaymentMethodsParamsEnvironment defines parameters for ListBuyerPaymentMethods.
type ListBuyerPaymentMethodsParamsEnvironment string

// UpdateBuyerJSONBody defines parameters for UpdateBuyer.
type UpdateBuyerJSONBody BuyerUpdate

// ListCardsRulesParams defines parameters for ListCardsRules.
type ListCardsRulesParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListCardsRulesParamsEnvironment `json:"environment,omitempty"`
}

// ListCardsRulesParamsEnvironment defines parameters for ListCardsRules.
type ListCardsRulesParamsEnvironment string

// AddCardRuleJSONBody defines parameters for AddCardRule.
type AddCardRuleJSONBody CardRuleRequest

// UpdateCardRuleJSONBody defines parameters for UpdateCardRule.
type UpdateCardRuleJSONBody CardRuleUpdate

// ListPaymentMethodsParams defines parameters for ListPaymentMethods.
type ListPaymentMethodsParams struct {

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentMethodsParamsEnvironment `json:"environment,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `id` that matches this value.
	BuyerId *string `json:"buyer_id,omitempty"`

	// Filters the results to only the items for which the `buyer` has an
	// `external_identifier` that matches this value.
	BuyerExternalIdentifier *string `json:"buyer_external_identifier,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListPaymentMethodsParamsEnvironment defines parameters for ListPaymentMethods.
type ListPaymentMethodsParamsEnvironment string

// StorePaymentMethodJSONBody defines parameters for StorePaymentMethod.
type StorePaymentMethodJSONBody CardRequest

// ListPaymentOptionsParams defines parameters for ListPaymentOptions.
type ListPaymentOptionsParams struct {

	// Filters the results to only the items which support this country code. A
	// country is formatted as 2-letter ISO country code.
	Country *string `json:"country,omitempty"`

	// Filters the results to only the items which support this currency code. A
	// currency is formatted as 3-letter ISO currency code.
	Currency *string `json:"currency,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentOptionsParamsEnvironment `json:"environment,omitempty"`
}

// ListPaymentOptionsParamsEnvironment defines parameters for ListPaymentOptions.
type ListPaymentOptionsParamsEnvironment string

// ListPaymentServiceDefinitionsParams defines parameters for ListPaymentServiceDefinitions.
type ListPaymentServiceDefinitionsParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListPaymentServicesParams defines parameters for ListPaymentServices.
type ListPaymentServicesParams struct {

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`

	// Filters the results to only the items for which the `method` has been set to
	// this value.
	Method *ListPaymentServicesParamsMethod `json:"method,omitempty"`

	// Filters the results to only the items available in this environment.
	Environment *ListPaymentServicesParamsEnvironment `json:"environment,omitempty"`
}

// ListPaymentServicesParamsMethod defines parameters for ListPaymentServices.
type ListPaymentServicesParamsMethod string

// ListPaymentServicesParamsEnvironment defines parameters for ListPaymentServices.
type ListPaymentServicesParamsEnvironment string

// AddPaymentServiceJSONBody defines parameters for AddPaymentService.
type AddPaymentServiceJSONBody PaymentServiceRequest

// UpdatePaymentServiceJSONBody defines parameters for UpdatePaymentService.
type UpdatePaymentServiceJSONBody PaymentServiceUpdate

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {

	// Filters the transactions to only the items for which the `id` or
	// `external_identifier` matches this value. This field allows for a partial
	// match, matching any transaction for which either of the fields partially or
	// completely matches.
	Search *string `json:"search,omitempty"`

	// Filters the results to only the transactions for which the `status`
	// matches this value.
	TransactionStatus *ListTransactionsParamsTransactionStatus `json:"transaction_status,omitempty"`

	// Filters the results to only transactions created before this ISO date-time string.
	BeforeCreatedAt *string `json:"before_created_at,omitempty"`

	// Filters the results to only transactions created after this ISO date-time string.
	AfterCreatedAt *string `json:"after_created_at,omitempty"`

	// Filters the results to only transactions last updated before this ISO
	// date-time string.
	BeforeUpdatedAt *string `json:"before_updated_at,omitempty"`

	// Filters the results to only transactions last updated after this ISO
	// date-time string.
	AfterUpdatedAt *string `json:"after_updated_at,omitempty"`

	// Defines the maximum number of items to return for this request.
	Limit *int32 `json:"limit,omitempty"`

	// A cursor that identifies the page of results to return. This is used to
	// paginate the results of this API.
	//
	// For the first page of results, this parameter can be left out.
	// For additional pages, use the value returned by the API in
	// the `next_cursor` field. Similarly the `previous_cursor` can be used to
	// reverse backwards in the list.
	Cursor *string `json:"cursor,omitempty"`
}

// ListTransactionsParamsTransactionStatus defines parameters for ListTransactions.
type ListTransactionsParamsTransactionStatus string

// AuthorizeNewTransactionJSONBody defines parameters for AuthorizeNewTransaction.
type AuthorizeNewTransactionJSONBody TransactionRequest

// CaptureTransactionJSONBody defines parameters for CaptureTransaction.
type CaptureTransactionJSONBody TransactionCaptureRequest

// AddBuyerJSONRequestBody defines body for AddBuyer for application/json ContentType.
type AddBuyerJSONRequestBody AddBuyerJSONBody

// UpdateBuyerJSONRequestBody defines body for UpdateBuyer for application/json ContentType.
type UpdateBuyerJSONRequestBody UpdateBuyerJSONBody

// AddCardRuleJSONRequestBody defines body for AddCardRule for application/json ContentType.
type AddCardRuleJSONRequestBody AddCardRuleJSONBody

// UpdateCardRuleJSONRequestBody defines body for UpdateCardRule for application/json ContentType.
type UpdateCardRuleJSONRequestBody UpdateCardRuleJSONBody

// StorePaymentMethodJSONRequestBody defines body for StorePaymentMethod for application/json ContentType.
type StorePaymentMethodJSONRequestBody StorePaymentMethodJSONBody

// AddPaymentServiceJSONRequestBody defines body for AddPaymentService for application/json ContentType.
type AddPaymentServiceJSONRequestBody AddPaymentServiceJSONBody

// UpdatePaymentServiceJSONRequestBody defines body for UpdatePaymentService for application/json ContentType.
type UpdatePaymentServiceJSONRequestBody UpdatePaymentServiceJSONBody

// AuthorizeNewTransactionJSONRequestBody defines body for AuthorizeNewTransaction for application/json ContentType.
type AuthorizeNewTransactionJSONRequestBody AuthorizeNewTransactionJSONBody

// CaptureTransactionJSONRequestBody defines body for CaptureTransaction for application/json ContentType.
type CaptureTransactionJSONRequestBody CaptureTransactionJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListBuyers request
	ListBuyers(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBuyer request  with any body
	AddBuyerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBuyer(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuyerPaymentMethods request
	ListBuyerPaymentMethods(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuyer request
	DeleteBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuyer request
	GetBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBuyer request  with any body
	UpdateBuyerWithBody(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBuyer(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCardsRules request
	ListCardsRules(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCardRule request  with any body
	AddCardRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCardRule(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCardRule request
	DeleteCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCardRule request
	GetCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCardRule request  with any body
	UpdateCardRuleWithBody(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCardRule(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentMethods request
	ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StorePaymentMethod request  with any body
	StorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StorePaymentMethod(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentMethod request
	DeletePaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentMethod request
	GetPaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentOptions request
	ListPaymentOptions(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentServiceDefinitions request
	ListPaymentServiceDefinitions(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentServiceDefinition request
	GetPaymentServiceDefinition(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentServices request
	ListPaymentServices(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPaymentService request  with any body
	AddPaymentServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPaymentService(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentService request
	DeletePaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentService request
	GetPaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePaymentService request  with any body
	UpdatePaymentServiceWithBody(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePaymentService(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactions request
	ListTransactions(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeNewTransaction request  with any body
	AuthorizeNewTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthorizeNewTransaction(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeTransaction request
	AuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaptureTransaction request  with any body
	CaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CaptureTransaction(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefundTransaction request
	RefundTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListBuyers(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuyersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuyerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuyerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBuyer(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBuyerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuyerPaymentMethods(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuyerPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuyerRequest(c.Server, buyerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuyer(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuyerRequest(c.Server, buyerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuyerWithBody(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuyerRequestWithBody(c.Server, buyerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuyer(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuyerRequest(c.Server, buyerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCardsRules(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCardsRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCardRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCardRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCardRule(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCardRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCardRuleRequest(c.Server, cardRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCardRule(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCardRuleRequest(c.Server, cardRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCardRuleWithBody(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCardRuleRequestWithBody(c.Server, cardRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCardRule(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCardRuleRequest(c.Server, cardRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePaymentMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePaymentMethodRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StorePaymentMethod(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStorePaymentMethodRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentMethodRequest(c.Server, paymentMethodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentMethod(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentMethodRequest(c.Server, paymentMethodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentOptions(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentServiceDefinitions(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentServiceDefinitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentServiceDefinition(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentServiceDefinitionRequest(c.Server, paymentServiceDefinitionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentServices(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPaymentServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPaymentServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPaymentService(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPaymentServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentServiceRequest(c.Server, paymentServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentService(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentServiceRequest(c.Server, paymentServiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentServiceWithBody(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentServiceRequestWithBody(c.Server, paymentServiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentService(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentServiceRequest(c.Server, paymentServiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactions(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeNewTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeNewTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeNewTransaction(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeNewTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaptureTransactionWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaptureTransactionRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaptureTransaction(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaptureTransactionRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefundTransaction(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefundTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListBuyersRequest generates requests for ListBuyers
func NewListBuyersRequest(server string, params *ListBuyersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBuyerRequest calls the generic AddBuyer builder with application/json body
func NewAddBuyerRequest(server string, body AddBuyerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBuyerRequestWithBody(server, "application/json", bodyReader)
}

// NewAddBuyerRequestWithBody generates requests for AddBuyer with any type of body
func NewAddBuyerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuyerPaymentMethodsRequest generates requests for ListBuyerPaymentMethods
func NewListBuyerPaymentMethodsRequest(server string, params *ListBuyerPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.BuyerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_id", runtime.ParamLocationQuery, *params.BuyerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerExternalIdentifier != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_external_identifier", runtime.ParamLocationQuery, *params.BuyerExternalIdentifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Country != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Currency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBuyerRequest generates requests for DeleteBuyer
func NewDeleteBuyerRequest(server string, buyerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuyerRequest generates requests for GetBuyer
func NewGetBuyerRequest(server string, buyerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBuyerRequest calls the generic UpdateBuyer builder with application/json body
func NewUpdateBuyerRequest(server string, buyerId string, body UpdateBuyerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBuyerRequestWithBody(server, buyerId, "application/json", bodyReader)
}

// NewUpdateBuyerRequestWithBody generates requests for UpdateBuyer with any type of body
func NewUpdateBuyerRequestWithBody(server string, buyerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, buyerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/buyers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCardsRulesRequest generates requests for ListCardsRules
func NewListCardsRulesRequest(server string, params *ListCardsRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCardRuleRequest calls the generic AddCardRule builder with application/json body
func NewAddCardRuleRequest(server string, body AddCardRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCardRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCardRuleRequestWithBody generates requests for AddCardRule with any type of body
func NewAddCardRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCardRuleRequest generates requests for DeleteCardRule
func NewDeleteCardRuleRequest(server string, cardRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCardRuleRequest generates requests for GetCardRule
func NewGetCardRuleRequest(server string, cardRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCardRuleRequest calls the generic UpdateCardRule builder with application/json body
func NewUpdateCardRuleRequest(server string, cardRuleId string, body UpdateCardRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCardRuleRequestWithBody(server, cardRuleId, "application/json", bodyReader)
}

// NewUpdateCardRuleRequestWithBody generates requests for UpdateCardRule with any type of body
func NewUpdateCardRuleRequestWithBody(server string, cardRuleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, cardRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/card-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPaymentMethodsRequest generates requests for ListPaymentMethods
func NewListPaymentMethodsRequest(server string, params *ListPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_id", runtime.ParamLocationQuery, *params.BuyerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BuyerExternalIdentifier != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyer_external_identifier", runtime.ParamLocationQuery, *params.BuyerExternalIdentifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStorePaymentMethodRequest calls the generic StorePaymentMethod builder with application/json body
func NewStorePaymentMethodRequest(server string, body StorePaymentMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStorePaymentMethodRequestWithBody(server, "application/json", bodyReader)
}

// NewStorePaymentMethodRequestWithBody generates requests for StorePaymentMethod with any type of body
func NewStorePaymentMethodRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentMethodRequest generates requests for DeletePaymentMethod
func NewDeletePaymentMethodRequest(server string, paymentMethodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, paymentMethodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentMethodRequest generates requests for GetPaymentMethod
func NewGetPaymentMethodRequest(server string, paymentMethodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, paymentMethodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentOptionsRequest generates requests for ListPaymentOptions
func NewListPaymentOptionsRequest(server string, params *ListPaymentOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-options")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Country != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Currency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency", runtime.ParamLocationQuery, *params.Currency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentServiceDefinitionsRequest generates requests for ListPaymentServiceDefinitions
func NewListPaymentServiceDefinitionsRequest(server string, params *ListPaymentServiceDefinitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-definitions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentServiceDefinitionRequest generates requests for GetPaymentServiceDefinition
func NewGetPaymentServiceDefinitionRequest(server string, paymentServiceDefinitionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_definition_id", runtime.ParamLocationPath, paymentServiceDefinitionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-definitions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentServicesRequest generates requests for ListPaymentServices
func NewListPaymentServicesRequest(server string, params *ListPaymentServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Method != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "method", runtime.ParamLocationQuery, *params.Method); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPaymentServiceRequest calls the generic AddPaymentService builder with application/json body
func NewAddPaymentServiceRequest(server string, body AddPaymentServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPaymentServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPaymentServiceRequestWithBody generates requests for AddPaymentService with any type of body
func NewAddPaymentServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentServiceRequest generates requests for DeletePaymentService
func NewDeletePaymentServiceRequest(server string, paymentServiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentServiceRequest generates requests for GetPaymentService
func NewGetPaymentServiceRequest(server string, paymentServiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePaymentServiceRequest calls the generic UpdatePaymentService builder with application/json body
func NewUpdatePaymentServiceRequest(server string, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePaymentServiceRequestWithBody(server, paymentServiceId, "application/json", bodyReader)
}

// NewUpdatePaymentServiceRequestWithBody generates requests for UpdatePaymentService with any type of body
func NewUpdatePaymentServiceRequestWithBody(server string, paymentServiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, paymentServiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TransactionStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_status", runtime.ParamLocationQuery, *params.TransactionStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BeforeCreatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_created_at", runtime.ParamLocationQuery, *params.BeforeCreatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AfterCreatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_created_at", runtime.ParamLocationQuery, *params.AfterCreatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BeforeUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_updated_at", runtime.ParamLocationQuery, *params.BeforeUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AfterUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_updated_at", runtime.ParamLocationQuery, *params.AfterUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeNewTransactionRequest calls the generic AuthorizeNewTransaction builder with application/json body
func NewAuthorizeNewTransactionRequest(server string, body AuthorizeNewTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthorizeNewTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthorizeNewTransactionRequestWithBody generates requests for AuthorizeNewTransaction with any type of body
func NewAuthorizeNewTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeTransactionRequest generates requests for AuthorizeTransaction
func NewAuthorizeTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCaptureTransactionRequest calls the generic CaptureTransaction builder with application/json body
func NewCaptureTransactionRequest(server string, transactionId string, body CaptureTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCaptureTransactionRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewCaptureTransactionRequestWithBody generates requests for CaptureTransaction with any type of body
func NewCaptureTransactionRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefundTransactionRequest generates requests for RefundTransaction
func NewRefundTransactionRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListBuyers request
	ListBuyersWithResponse(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*ListBuyersResponse, error)

	// AddBuyer request  with any body
	AddBuyerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error)

	AddBuyerWithResponse(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error)

	// ListBuyerPaymentMethods request
	ListBuyerPaymentMethodsWithResponse(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListBuyerPaymentMethodsResponse, error)

	// DeleteBuyer request
	DeleteBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*DeleteBuyerResponse, error)

	// GetBuyer request
	GetBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*GetBuyerResponse, error)

	// UpdateBuyer request  with any body
	UpdateBuyerWithBodyWithResponse(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error)

	UpdateBuyerWithResponse(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error)

	// ListCardsRules request
	ListCardsRulesWithResponse(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*ListCardsRulesResponse, error)

	// AddCardRule request  with any body
	AddCardRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error)

	AddCardRuleWithResponse(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error)

	// DeleteCardRule request
	DeleteCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*DeleteCardRuleResponse, error)

	// GetCardRule request
	GetCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*GetCardRuleResponse, error)

	// UpdateCardRule request  with any body
	UpdateCardRuleWithBodyWithResponse(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error)

	UpdateCardRuleWithResponse(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error)

	// ListPaymentMethods request
	ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error)

	// StorePaymentMethod request  with any body
	StorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error)

	StorePaymentMethodWithResponse(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error)

	// DeletePaymentMethod request
	DeletePaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error)

	// GetPaymentMethod request
	GetPaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*GetPaymentMethodResponse, error)

	// ListPaymentOptions request
	ListPaymentOptionsWithResponse(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*ListPaymentOptionsResponse, error)

	// ListPaymentServiceDefinitions request
	ListPaymentServiceDefinitionsWithResponse(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*ListPaymentServiceDefinitionsResponse, error)

	// GetPaymentServiceDefinition request
	GetPaymentServiceDefinitionWithResponse(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceDefinitionResponse, error)

	// ListPaymentServices request
	ListPaymentServicesWithResponse(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*ListPaymentServicesResponse, error)

	// AddPaymentService request  with any body
	AddPaymentServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error)

	AddPaymentServiceWithResponse(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error)

	// DeletePaymentService request
	DeletePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*DeletePaymentServiceResponse, error)

	// GetPaymentService request
	GetPaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceResponse, error)

	// UpdatePaymentService request  with any body
	UpdatePaymentServiceWithBodyWithResponse(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error)

	UpdatePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error)

	// ListTransactions request
	ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error)

	// AuthorizeNewTransaction request  with any body
	AuthorizeNewTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error)

	AuthorizeNewTransactionWithResponse(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error)

	// GetTransaction request
	GetTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// AuthorizeTransaction request
	AuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AuthorizeTransactionResponse, error)

	// CaptureTransaction request  with any body
	CaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error)

	CaptureTransactionWithResponse(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error)

	// RefundTransaction request
	RefundTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*RefundTransactionResponse, error)
}

type ListBuyersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyers
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListBuyersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuyersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Buyer
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON409      *Error409DuplicateRecord
}

// Status returns HTTPResponse.Status
func (r AddBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuyerPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethodsTokenized
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r ListBuyerPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuyerPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyer
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBuyerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Buyer
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateBuyerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBuyerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCardsRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRules
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListCardsRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCardsRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CardRule
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AddCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON403      *ErrorGeneric
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRule
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCardRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardRule
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCardRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCardRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethods
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StorePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Card
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r StorePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StorePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethod
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentOptions
	JSON400      *Error400BadRequest
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentServiceDefinitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServiceDefinitions
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentServiceDefinitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentServiceDefinitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentServiceDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServiceDefinition
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentServiceDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentServiceDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentServices
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListPaymentServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentService
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AddPaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentService
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePaymentServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentService
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON404      *Error404NotFound
}

// Status returns HTTPResponse.Status
func (r UpdatePaymentServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePaymentServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeNewTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Transaction
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
}

// Status returns HTTPResponse.Status
func (r AuthorizeNewTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeNewTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON401      *Error401Unauthorized
	JSON404      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON404      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r AuthorizeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaptureTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON400      *ErrorGeneric
	JSON401      *Error401Unauthorized
	JSON404      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CaptureTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaptureTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefundTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON401      *Error401Unauthorized
	JSON404      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r RefundTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefundTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListBuyersWithResponse request returning *ListBuyersResponse
func (c *ClientWithResponses) ListBuyersWithResponse(ctx context.Context, params *ListBuyersParams, reqEditors ...RequestEditorFn) (*ListBuyersResponse, error) {
	rsp, err := c.ListBuyers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuyersResponse(rsp)
}

// AddBuyerWithBodyWithResponse request with arbitrary body returning *AddBuyerResponse
func (c *ClientWithResponses) AddBuyerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error) {
	rsp, err := c.AddBuyerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuyerResponse(rsp)
}

func (c *ClientWithResponses) AddBuyerWithResponse(ctx context.Context, body AddBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBuyerResponse, error) {
	rsp, err := c.AddBuyer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBuyerResponse(rsp)
}

// ListBuyerPaymentMethodsWithResponse request returning *ListBuyerPaymentMethodsResponse
func (c *ClientWithResponses) ListBuyerPaymentMethodsWithResponse(ctx context.Context, params *ListBuyerPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListBuyerPaymentMethodsResponse, error) {
	rsp, err := c.ListBuyerPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuyerPaymentMethodsResponse(rsp)
}

// DeleteBuyerWithResponse request returning *DeleteBuyerResponse
func (c *ClientWithResponses) DeleteBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*DeleteBuyerResponse, error) {
	rsp, err := c.DeleteBuyer(ctx, buyerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuyerResponse(rsp)
}

// GetBuyerWithResponse request returning *GetBuyerResponse
func (c *ClientWithResponses) GetBuyerWithResponse(ctx context.Context, buyerId string, reqEditors ...RequestEditorFn) (*GetBuyerResponse, error) {
	rsp, err := c.GetBuyer(ctx, buyerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuyerResponse(rsp)
}

// UpdateBuyerWithBodyWithResponse request with arbitrary body returning *UpdateBuyerResponse
func (c *ClientWithResponses) UpdateBuyerWithBodyWithResponse(ctx context.Context, buyerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error) {
	rsp, err := c.UpdateBuyerWithBody(ctx, buyerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuyerResponse(rsp)
}

func (c *ClientWithResponses) UpdateBuyerWithResponse(ctx context.Context, buyerId string, body UpdateBuyerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuyerResponse, error) {
	rsp, err := c.UpdateBuyer(ctx, buyerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuyerResponse(rsp)
}

// ListCardsRulesWithResponse request returning *ListCardsRulesResponse
func (c *ClientWithResponses) ListCardsRulesWithResponse(ctx context.Context, params *ListCardsRulesParams, reqEditors ...RequestEditorFn) (*ListCardsRulesResponse, error) {
	rsp, err := c.ListCardsRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCardsRulesResponse(rsp)
}

// AddCardRuleWithBodyWithResponse request with arbitrary body returning *AddCardRuleResponse
func (c *ClientWithResponses) AddCardRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error) {
	rsp, err := c.AddCardRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCardRuleResponse(rsp)
}

func (c *ClientWithResponses) AddCardRuleWithResponse(ctx context.Context, body AddCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCardRuleResponse, error) {
	rsp, err := c.AddCardRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCardRuleResponse(rsp)
}

// DeleteCardRuleWithResponse request returning *DeleteCardRuleResponse
func (c *ClientWithResponses) DeleteCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*DeleteCardRuleResponse, error) {
	rsp, err := c.DeleteCardRule(ctx, cardRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCardRuleResponse(rsp)
}

// GetCardRuleWithResponse request returning *GetCardRuleResponse
func (c *ClientWithResponses) GetCardRuleWithResponse(ctx context.Context, cardRuleId string, reqEditors ...RequestEditorFn) (*GetCardRuleResponse, error) {
	rsp, err := c.GetCardRule(ctx, cardRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCardRuleResponse(rsp)
}

// UpdateCardRuleWithBodyWithResponse request with arbitrary body returning *UpdateCardRuleResponse
func (c *ClientWithResponses) UpdateCardRuleWithBodyWithResponse(ctx context.Context, cardRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error) {
	rsp, err := c.UpdateCardRuleWithBody(ctx, cardRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCardRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateCardRuleWithResponse(ctx context.Context, cardRuleId string, body UpdateCardRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCardRuleResponse, error) {
	rsp, err := c.UpdateCardRule(ctx, cardRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCardRuleResponse(rsp)
}

// ListPaymentMethodsWithResponse request returning *ListPaymentMethodsResponse
func (c *ClientWithResponses) ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error) {
	rsp, err := c.ListPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentMethodsResponse(rsp)
}

// StorePaymentMethodWithBodyWithResponse request with arbitrary body returning *StorePaymentMethodResponse
func (c *ClientWithResponses) StorePaymentMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error) {
	rsp, err := c.StorePaymentMethodWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePaymentMethodResponse(rsp)
}

func (c *ClientWithResponses) StorePaymentMethodWithResponse(ctx context.Context, body StorePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*StorePaymentMethodResponse, error) {
	rsp, err := c.StorePaymentMethod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStorePaymentMethodResponse(rsp)
}

// DeletePaymentMethodWithResponse request returning *DeletePaymentMethodResponse
func (c *ClientWithResponses) DeletePaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error) {
	rsp, err := c.DeletePaymentMethod(ctx, paymentMethodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentMethodResponse(rsp)
}

// GetPaymentMethodWithResponse request returning *GetPaymentMethodResponse
func (c *ClientWithResponses) GetPaymentMethodWithResponse(ctx context.Context, paymentMethodId string, reqEditors ...RequestEditorFn) (*GetPaymentMethodResponse, error) {
	rsp, err := c.GetPaymentMethod(ctx, paymentMethodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentMethodResponse(rsp)
}

// ListPaymentOptionsWithResponse request returning *ListPaymentOptionsResponse
func (c *ClientWithResponses) ListPaymentOptionsWithResponse(ctx context.Context, params *ListPaymentOptionsParams, reqEditors ...RequestEditorFn) (*ListPaymentOptionsResponse, error) {
	rsp, err := c.ListPaymentOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentOptionsResponse(rsp)
}

// ListPaymentServiceDefinitionsWithResponse request returning *ListPaymentServiceDefinitionsResponse
func (c *ClientWithResponses) ListPaymentServiceDefinitionsWithResponse(ctx context.Context, params *ListPaymentServiceDefinitionsParams, reqEditors ...RequestEditorFn) (*ListPaymentServiceDefinitionsResponse, error) {
	rsp, err := c.ListPaymentServiceDefinitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentServiceDefinitionsResponse(rsp)
}

// GetPaymentServiceDefinitionWithResponse request returning *GetPaymentServiceDefinitionResponse
func (c *ClientWithResponses) GetPaymentServiceDefinitionWithResponse(ctx context.Context, paymentServiceDefinitionId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceDefinitionResponse, error) {
	rsp, err := c.GetPaymentServiceDefinition(ctx, paymentServiceDefinitionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentServiceDefinitionResponse(rsp)
}

// ListPaymentServicesWithResponse request returning *ListPaymentServicesResponse
func (c *ClientWithResponses) ListPaymentServicesWithResponse(ctx context.Context, params *ListPaymentServicesParams, reqEditors ...RequestEditorFn) (*ListPaymentServicesResponse, error) {
	rsp, err := c.ListPaymentServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentServicesResponse(rsp)
}

// AddPaymentServiceWithBodyWithResponse request with arbitrary body returning *AddPaymentServiceResponse
func (c *ClientWithResponses) AddPaymentServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error) {
	rsp, err := c.AddPaymentServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPaymentServiceResponse(rsp)
}

func (c *ClientWithResponses) AddPaymentServiceWithResponse(ctx context.Context, body AddPaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPaymentServiceResponse, error) {
	rsp, err := c.AddPaymentService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPaymentServiceResponse(rsp)
}

// DeletePaymentServiceWithResponse request returning *DeletePaymentServiceResponse
func (c *ClientWithResponses) DeletePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*DeletePaymentServiceResponse, error) {
	rsp, err := c.DeletePaymentService(ctx, paymentServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentServiceResponse(rsp)
}

// GetPaymentServiceWithResponse request returning *GetPaymentServiceResponse
func (c *ClientWithResponses) GetPaymentServiceWithResponse(ctx context.Context, paymentServiceId string, reqEditors ...RequestEditorFn) (*GetPaymentServiceResponse, error) {
	rsp, err := c.GetPaymentService(ctx, paymentServiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentServiceResponse(rsp)
}

// UpdatePaymentServiceWithBodyWithResponse request with arbitrary body returning *UpdatePaymentServiceResponse
func (c *ClientWithResponses) UpdatePaymentServiceWithBodyWithResponse(ctx context.Context, paymentServiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error) {
	rsp, err := c.UpdatePaymentServiceWithBody(ctx, paymentServiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdatePaymentServiceWithResponse(ctx context.Context, paymentServiceId string, body UpdatePaymentServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentServiceResponse, error) {
	rsp, err := c.UpdatePaymentService(ctx, paymentServiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentServiceResponse(rsp)
}

// ListTransactionsWithResponse request returning *ListTransactionsResponse
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error) {
	rsp, err := c.ListTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResponse(rsp)
}

// AuthorizeNewTransactionWithBodyWithResponse request with arbitrary body returning *AuthorizeNewTransactionResponse
func (c *ClientWithResponses) AuthorizeNewTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error) {
	rsp, err := c.AuthorizeNewTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeNewTransactionResponse(rsp)
}

func (c *ClientWithResponses) AuthorizeNewTransactionWithResponse(ctx context.Context, body AuthorizeNewTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeNewTransactionResponse, error) {
	rsp, err := c.AuthorizeNewTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeNewTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// AuthorizeTransactionWithResponse request returning *AuthorizeTransactionResponse
func (c *ClientWithResponses) AuthorizeTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*AuthorizeTransactionResponse, error) {
	rsp, err := c.AuthorizeTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeTransactionResponse(rsp)
}

// CaptureTransactionWithBodyWithResponse request with arbitrary body returning *CaptureTransactionResponse
func (c *ClientWithResponses) CaptureTransactionWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error) {
	rsp, err := c.CaptureTransactionWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaptureTransactionResponse(rsp)
}

func (c *ClientWithResponses) CaptureTransactionWithResponse(ctx context.Context, transactionId string, body CaptureTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CaptureTransactionResponse, error) {
	rsp, err := c.CaptureTransaction(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaptureTransactionResponse(rsp)
}

// RefundTransactionWithResponse request returning *RefundTransactionResponse
func (c *ClientWithResponses) RefundTransactionWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*RefundTransactionResponse, error) {
	rsp, err := c.RefundTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefundTransactionResponse(rsp)
}

// ParseListBuyersResponse parses an HTTP response from a ListBuyersWithResponse call
func ParseListBuyersResponse(rsp *http.Response) (*ListBuyersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBuyersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddBuyerResponse parses an HTTP response from a AddBuyerWithResponse call
func ParseAddBuyerResponse(rsp *http.Response) (*AddBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409DuplicateRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseListBuyerPaymentMethodsResponse parses an HTTP response from a ListBuyerPaymentMethodsWithResponse call
func ParseListBuyerPaymentMethodsResponse(rsp *http.Response) (*ListBuyerPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBuyerPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethodsTokenized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBuyerResponse parses an HTTP response from a DeleteBuyerWithResponse call
func ParseDeleteBuyerResponse(rsp *http.Response) (*DeleteBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBuyerResponse parses an HTTP response from a GetBuyerWithResponse call
func ParseGetBuyerResponse(rsp *http.Response) (*GetBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBuyerResponse parses an HTTP response from a UpdateBuyerWithResponse call
func ParseUpdateBuyerResponse(rsp *http.Response) (*UpdateBuyerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBuyerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Buyer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCardsRulesResponse parses an HTTP response from a ListCardsRulesWithResponse call
func ParseListCardsRulesResponse(rsp *http.Response) (*ListCardsRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCardsRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddCardRuleResponse parses an HTTP response from a AddCardRuleWithResponse call
func ParseAddCardRuleResponse(rsp *http.Response) (*AddCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteCardRuleResponse parses an HTTP response from a DeleteCardRuleWithResponse call
func ParseDeleteCardRuleResponse(rsp *http.Response) (*DeleteCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCardRuleResponse parses an HTTP response from a GetCardRuleWithResponse call
func ParseGetCardRuleResponse(rsp *http.Response) (*GetCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCardRuleResponse parses an HTTP response from a UpdateCardRuleWithResponse call
func ParseUpdateCardRuleResponse(rsp *http.Response) (*UpdateCardRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCardRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentMethodsResponse parses an HTTP response from a ListPaymentMethodsWithResponse call
func ParseListPaymentMethodsResponse(rsp *http.Response) (*ListPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseStorePaymentMethodResponse parses an HTTP response from a StorePaymentMethodWithResponse call
func ParseStorePaymentMethodResponse(rsp *http.Response) (*StorePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StorePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Card
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePaymentMethodResponse parses an HTTP response from a DeletePaymentMethodWithResponse call
func ParseDeletePaymentMethodResponse(rsp *http.Response) (*DeletePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPaymentMethodResponse parses an HTTP response from a GetPaymentMethodWithResponse call
func ParseGetPaymentMethodResponse(rsp *http.Response) (*GetPaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentOptionsResponse parses an HTTP response from a ListPaymentOptionsWithResponse call
func ParseListPaymentOptionsResponse(rsp *http.Response) (*ListPaymentOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListPaymentServiceDefinitionsResponse parses an HTTP response from a ListPaymentServiceDefinitionsWithResponse call
func ParseListPaymentServiceDefinitionsResponse(rsp *http.Response) (*ListPaymentServiceDefinitionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentServiceDefinitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServiceDefinitions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPaymentServiceDefinitionResponse parses an HTTP response from a GetPaymentServiceDefinitionWithResponse call
func ParseGetPaymentServiceDefinitionResponse(rsp *http.Response) (*GetPaymentServiceDefinitionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentServiceDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServiceDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPaymentServicesResponse parses an HTTP response from a ListPaymentServicesWithResponse call
func ParseListPaymentServicesResponse(rsp *http.Response) (*ListPaymentServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentServices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAddPaymentServiceResponse parses an HTTP response from a AddPaymentServiceWithResponse call
func ParseAddPaymentServiceResponse(rsp *http.Response) (*AddPaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddPaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeletePaymentServiceResponse parses an HTTP response from a DeletePaymentServiceWithResponse call
func ParseDeletePaymentServiceResponse(rsp *http.Response) (*DeletePaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPaymentServiceResponse parses an HTTP response from a GetPaymentServiceWithResponse call
func ParseGetPaymentServiceResponse(rsp *http.Response) (*GetPaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePaymentServiceResponse parses an HTTP response from a UpdatePaymentServiceWithResponse call
func ParseUpdatePaymentServiceResponse(rsp *http.Response) (*UpdatePaymentServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePaymentServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListTransactionsResponse parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResponse(rsp *http.Response) (*ListTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAuthorizeNewTransactionResponse parses an HTTP response from a AuthorizeNewTransactionWithResponse call
func ParseAuthorizeNewTransactionResponse(rsp *http.Response) (*AuthorizeNewTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeNewTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAuthorizeTransactionResponse parses an HTTP response from a AuthorizeTransactionWithResponse call
func ParseAuthorizeTransactionResponse(rsp *http.Response) (*AuthorizeTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCaptureTransactionResponse parses an HTTP response from a CaptureTransactionWithResponse call
func ParseCaptureTransactionResponse(rsp *http.Response) (*CaptureTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CaptureTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRefundTransactionResponse parses an HTTP response from a RefundTransactionWithResponse call
func ParseRefundTransactionResponse(rsp *http.Response) (*RefundTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RefundTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List buyers
	// (GET /buyers)
	ListBuyers(ctx echo.Context, params ListBuyersParams) error
	// New buyer
	// (POST /buyers)
	AddBuyer(ctx echo.Context) error
	// List stored payment methods for a buyer
	// (GET /buyers/payment-methods)
	ListBuyerPaymentMethods(ctx echo.Context, params ListBuyerPaymentMethodsParams) error
	// Delete buyer
	// (DELETE /buyers/{buyer_id})
	DeleteBuyer(ctx echo.Context, buyerId string) error
	// Get buyer
	// (GET /buyers/{buyer_id})
	GetBuyer(ctx echo.Context, buyerId string) error
	// Update buyer
	// (PUT /buyers/{buyer_id})
	UpdateBuyer(ctx echo.Context, buyerId string) error
	// List card rules
	// (GET /card-rules)
	ListCardsRules(ctx echo.Context, params ListCardsRulesParams) error
	// Create card rule
	// (POST /card-rules)
	AddCardRule(ctx echo.Context) error
	// Delete card rule
	// (DELETE /card-rules/{card_rule_id})
	DeleteCardRule(ctx echo.Context, cardRuleId string) error
	// Get card rule
	// (GET /card-rules/{card_rule_id})
	GetCardRule(ctx echo.Context, cardRuleId string) error
	// Update card rule
	// (PUT /card-rules/{card_rule_id})
	UpdateCardRule(ctx echo.Context, cardRuleId string) error
	// List payment methods
	// (GET /payment-methods)
	ListPaymentMethods(ctx echo.Context, params ListPaymentMethodsParams) error
	// New payment method
	// (POST /payment-methods)
	StorePaymentMethod(ctx echo.Context) error
	// Delete payment method
	// (DELETE /payment-methods/{payment_method_id})
	DeletePaymentMethod(ctx echo.Context, paymentMethodId string) error
	// Get stored payment method
	// (GET /payment-methods/{payment_method_id})
	GetPaymentMethod(ctx echo.Context, paymentMethodId string) error
	// List payment options
	// (GET /payment-options)
	ListPaymentOptions(ctx echo.Context, params ListPaymentOptionsParams) error
	// List payment service definitions
	// (GET /payment-service-definitions)
	ListPaymentServiceDefinitions(ctx echo.Context, params ListPaymentServiceDefinitionsParams) error
	// Get payment service definition
	// (GET /payment-service-definitions/{payment_service_definition_id})
	GetPaymentServiceDefinition(ctx echo.Context, paymentServiceDefinitionId string) error
	// List payment services
	// (GET /payment-services)
	ListPaymentServices(ctx echo.Context, params ListPaymentServicesParams) error
	// New payment service
	// (POST /payment-services)
	AddPaymentService(ctx echo.Context) error
	// Delete payment service
	// (DELETE /payment-services/{payment_service_id})
	DeletePaymentService(ctx echo.Context, paymentServiceId string) error
	// Get payment service
	// (GET /payment-services/{payment_service_id})
	GetPaymentService(ctx echo.Context, paymentServiceId string) error
	// Update payment service
	// (PUT /payment-services/{payment_service_id})
	UpdatePaymentService(ctx echo.Context, paymentServiceId string) error
	// List transactions
	// (GET /transactions)
	ListTransactions(ctx echo.Context, params ListTransactionsParams) error
	// New transaction
	// (POST /transactions)
	AuthorizeNewTransaction(ctx echo.Context) error
	// Get transaction
	// (GET /transactions/{transaction_id})
	GetTransaction(ctx echo.Context, transactionId string) error
	// Authorize approved transaction
	// (POST /transactions/{transaction_id}/authorize)
	AuthorizeTransaction(ctx echo.Context, transactionId string) error
	// Capture transaction
	// (POST /transactions/{transaction_id}/capture)
	CaptureTransaction(ctx echo.Context, transactionId string) error
	// Refund or void transaction
	// (POST /transactions/{transaction_id}/refund)
	RefundTransaction(ctx echo.Context, transactionId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListBuyers converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuyers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuyersParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBuyers(ctx, params)
	return err
}

// AddBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) AddBuyer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddBuyer(ctx)
	return err
}

// ListBuyerPaymentMethods converts echo context to params.
func (w *ServerInterfaceWrapper) ListBuyerPaymentMethods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBuyerPaymentMethodsParams
	// ------------- Optional query parameter "buyer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_id", ctx.QueryParams(), &params.BuyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	// ------------- Optional query parameter "buyer_external_identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_external_identifier", ctx.QueryParams(), &params.BuyerExternalIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_external_identifier: %s", err))
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "currency" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency", ctx.QueryParams(), &params.Currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBuyerPaymentMethods(ctx, params)
	return err
}

// DeleteBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteBuyer(ctx, buyerId)
	return err
}

// GetBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) GetBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBuyer(ctx, buyerId)
	return err
}

// UpdateBuyer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBuyer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "buyer_id" -------------
	var buyerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "buyer_id", runtime.ParamLocationPath, ctx.Param("buyer_id"), &buyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateBuyer(ctx, buyerId)
	return err
}

// ListCardsRules converts echo context to params.
func (w *ServerInterfaceWrapper) ListCardsRules(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCardsRulesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListCardsRules(ctx, params)
	return err
}

// AddCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) AddCardRule(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddCardRule(ctx)
	return err
}

// DeleteCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCardRule(ctx, cardRuleId)
	return err
}

// GetCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) GetCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCardRule(ctx, cardRuleId)
	return err
}

// UpdateCardRule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCardRule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "card_rule_id" -------------
	var cardRuleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "card_rule_id", runtime.ParamLocationPath, ctx.Param("card_rule_id"), &cardRuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter card_rule_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCardRule(ctx, cardRuleId)
	return err
}

// ListPaymentMethods converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentMethods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentMethodsParams
	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// ------------- Optional query parameter "buyer_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_id", ctx.QueryParams(), &params.BuyerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_id: %s", err))
	}

	// ------------- Optional query parameter "buyer_external_identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "buyer_external_identifier", ctx.QueryParams(), &params.BuyerExternalIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter buyer_external_identifier: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentMethods(ctx, params)
	return err
}

// StorePaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) StorePaymentMethod(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StorePaymentMethod(ctx)
	return err
}

// DeletePaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePaymentMethod(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_method_id" -------------
	var paymentMethodId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, ctx.Param("payment_method_id"), &paymentMethodId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_method_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePaymentMethod(ctx, paymentMethodId)
	return err
}

// GetPaymentMethod converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentMethod(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_method_id" -------------
	var paymentMethodId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_method_id", runtime.ParamLocationPath, ctx.Param("payment_method_id"), &paymentMethodId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_method_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentMethod(ctx, paymentMethodId)
	return err
}

// ListPaymentOptions converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentOptions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentOptionsParams
	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", ctx.QueryParams(), &params.Country)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter country: %s", err))
	}

	// ------------- Optional query parameter "currency" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency", ctx.QueryParams(), &params.Currency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentOptions(ctx, params)
	return err
}

// ListPaymentServiceDefinitions converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentServiceDefinitions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentServiceDefinitionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentServiceDefinitions(ctx, params)
	return err
}

// GetPaymentServiceDefinition converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentServiceDefinition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_definition_id" -------------
	var paymentServiceDefinitionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_definition_id", runtime.ParamLocationPath, ctx.Param("payment_service_definition_id"), &paymentServiceDefinitionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_definition_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentServiceDefinition(ctx, paymentServiceDefinitionId)
	return err
}

// ListPaymentServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListPaymentServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPaymentServicesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "method" -------------

	err = runtime.BindQueryParameter("form", true, false, "method", ctx.QueryParams(), &params.Method)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter method: %s", err))
	}

	// ------------- Optional query parameter "environment" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment", ctx.QueryParams(), &params.Environment)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPaymentServices(ctx, params)
	return err
}

// AddPaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) AddPaymentService(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddPaymentService(ctx)
	return err
}

// DeletePaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePaymentService(ctx, paymentServiceId)
	return err
}

// GetPaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) GetPaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPaymentService(ctx, paymentServiceId)
	return err
}

// UpdatePaymentService converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePaymentService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "payment_service_id" -------------
	var paymentServiceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "payment_service_id", runtime.ParamLocationPath, ctx.Param("payment_service_id"), &paymentServiceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payment_service_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdatePaymentService(ctx, paymentServiceId)
	return err
}

// ListTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) ListTransactions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTransactionsParams
	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// ------------- Optional query parameter "transaction_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "transaction_status", ctx.QueryParams(), &params.TransactionStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_status: %s", err))
	}

	// ------------- Optional query parameter "before_created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "before_created_at", ctx.QueryParams(), &params.BeforeCreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before_created_at: %s", err))
	}

	// ------------- Optional query parameter "after_created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_created_at", ctx.QueryParams(), &params.AfterCreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after_created_at: %s", err))
	}

	// ------------- Optional query parameter "before_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "before_updated_at", ctx.QueryParams(), &params.BeforeUpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before_updated_at: %s", err))
	}

	// ------------- Optional query parameter "after_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "after_updated_at", ctx.QueryParams(), &params.AfterUpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after_updated_at: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListTransactions(ctx, params)
	return err
}

// AuthorizeNewTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AuthorizeNewTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthorizeNewTransaction(ctx)
	return err
}

// GetTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransaction(ctx, transactionId)
	return err
}

// AuthorizeTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AuthorizeTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthorizeTransaction(ctx, transactionId)
	return err
}

// CaptureTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) CaptureTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CaptureTransaction(ctx, transactionId)
	return err
}

// RefundTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RefundTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RefundTransaction(ctx, transactionId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/buyers", wrapper.ListBuyers)
	router.POST(baseURL+"/buyers", wrapper.AddBuyer)
	router.GET(baseURL+"/buyers/payment-methods", wrapper.ListBuyerPaymentMethods)
	router.DELETE(baseURL+"/buyers/:buyer_id", wrapper.DeleteBuyer)
	router.GET(baseURL+"/buyers/:buyer_id", wrapper.GetBuyer)
	router.PUT(baseURL+"/buyers/:buyer_id", wrapper.UpdateBuyer)
	router.GET(baseURL+"/card-rules", wrapper.ListCardsRules)
	router.POST(baseURL+"/card-rules", wrapper.AddCardRule)
	router.DELETE(baseURL+"/card-rules/:card_rule_id", wrapper.DeleteCardRule)
	router.GET(baseURL+"/card-rules/:card_rule_id", wrapper.GetCardRule)
	router.PUT(baseURL+"/card-rules/:card_rule_id", wrapper.UpdateCardRule)
	router.GET(baseURL+"/payment-methods", wrapper.ListPaymentMethods)
	router.POST(baseURL+"/payment-methods", wrapper.StorePaymentMethod)
	router.DELETE(baseURL+"/payment-methods/:payment_method_id", wrapper.DeletePaymentMethod)
	router.GET(baseURL+"/payment-methods/:payment_method_id", wrapper.GetPaymentMethod)
	router.GET(baseURL+"/payment-options", wrapper.ListPaymentOptions)
	router.GET(baseURL+"/payment-service-definitions", wrapper.ListPaymentServiceDefinitions)
	router.GET(baseURL+"/payment-service-definitions/:payment_service_definition_id", wrapper.GetPaymentServiceDefinition)
	router.GET(baseURL+"/payment-services", wrapper.ListPaymentServices)
	router.POST(baseURL+"/payment-services", wrapper.AddPaymentService)
	router.DELETE(baseURL+"/payment-services/:payment_service_id", wrapper.DeletePaymentService)
	router.GET(baseURL+"/payment-services/:payment_service_id", wrapper.GetPaymentService)
	router.PUT(baseURL+"/payment-services/:payment_service_id", wrapper.UpdatePaymentService)
	router.GET(baseURL+"/transactions", wrapper.ListTransactions)
	router.POST(baseURL+"/transactions", wrapper.AuthorizeNewTransaction)
	router.GET(baseURL+"/transactions/:transaction_id", wrapper.GetTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/authorize", wrapper.AuthorizeTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/capture", wrapper.CaptureTransaction)
	router.POST(baseURL+"/transactions/:transaction_id/refund", wrapper.RefundTransaction)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}

