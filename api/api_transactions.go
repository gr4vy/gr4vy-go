/*
 * Gr4vy API
 *
 * Welcome to the Gr4vy API reference documentation. Our API is still very much a work in product and subject to change.
 *
 * API version: 1.1.0-beta
 * Contact: code@gr4vy.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package Openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// TransactionsApiService TransactionsApi service
type TransactionsApiService service

type ApiAuthorizeNewTransactionRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionRequest *TransactionRequest
}

func (r ApiAuthorizeNewTransactionRequest) TransactionRequest(transactionRequest TransactionRequest) ApiAuthorizeNewTransactionRequest {
	r.transactionRequest = &transactionRequest
	return r
}

func (r ApiAuthorizeNewTransactionRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.AuthorizeNewTransactionExecute(r)
}

/*
 * AuthorizeNewTransaction New transaction
 * Attempts to create an authorization for a payment method. In some cases it is
not possible to create the authorization without redirecting the user for
their authorization. In these cases the status is set to
`buyer_approval_pending` and an `approval_url` is returned.

Additionally, this endpoint accepts a few additional fields that allow for
simultaneous capturing and storage of the payment method.

* `store` - Use this field to store the payment method for
future use. Not all payment methods support this feature.
* `capture` - Use this method to also perform a capture of the transaction
after it has been authorized.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAuthorizeNewTransactionRequest
 */
func (a *TransactionsApiService) AuthorizeNewTransaction(ctx _context.Context) ApiAuthorizeNewTransactionRequest {
	return ApiAuthorizeNewTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *TransactionsApiService) AuthorizeNewTransactionExecute(r ApiAuthorizeNewTransactionRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.AuthorizeNewTransaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCaptureTransactionRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
	transactionCaptureRequest *TransactionCaptureRequest
}

func (r ApiCaptureTransactionRequest) TransactionCaptureRequest(transactionCaptureRequest TransactionCaptureRequest) ApiCaptureTransactionRequest {
	r.transactionCaptureRequest = &transactionCaptureRequest
	return r
}

func (r ApiCaptureTransactionRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.CaptureTransactionExecute(r)
}

/*
 * CaptureTransaction Capture transaction
 * Captures a previously authorized transaction.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @return ApiCaptureTransactionRequest
 */
func (a *TransactionsApiService) CaptureTransaction(ctx _context.Context, transactionId string) ApiCaptureTransactionRequest {
	return ApiCaptureTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *TransactionsApiService) CaptureTransactionExecute(r ApiCaptureTransactionRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.CaptureTransaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}/capture"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionCaptureRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
}


func (r ApiGetTransactionRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.GetTransactionExecute(r)
}

/*
 * GetTransaction Get transaction
 * Get information about a transaction.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @return ApiGetTransactionRequest
 */
func (a *TransactionsApiService) GetTransaction(ctx _context.Context, transactionId string) ApiGetTransactionRequest {
	return ApiGetTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *TransactionsApiService) GetTransactionExecute(r ApiGetTransactionRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionRefundRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
	refundId string
}


func (r ApiGetTransactionRefundRequest) Execute() (Refund, *_nethttp.Response, error) {
	return r.ApiService.GetTransactionRefundExecute(r)
}

/*
 * GetTransactionRefund Get transaction refund
 * Gets information about a refund associated with a certain transaction.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @param refundId The unique ID of the refund.
 * @return ApiGetTransactionRefundRequest
 */
func (a *TransactionsApiService) GetTransactionRefund(ctx _context.Context, transactionId string, refundId string) ApiGetTransactionRefundRequest {
	return ApiGetTransactionRefundRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
		refundId: refundId,
	}
}

/*
 * Execute executes the request
 * @return Refund
 */
func (a *TransactionsApiService) GetTransactionRefundExecute(r ApiGetTransactionRefundRequest) (Refund, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Refund
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransactionRefund")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}/refunds/{refund_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"refund_id"+"}", _neturl.PathEscape(parameterToString(r.refundId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionRefundsRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
	limit *int32
	cursor *string
}

func (r ApiListTransactionRefundsRequest) Limit(limit int32) ApiListTransactionRefundsRequest {
	r.limit = &limit
	return r
}
func (r ApiListTransactionRefundsRequest) Cursor(cursor string) ApiListTransactionRefundsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiListTransactionRefundsRequest) Execute() (Refunds, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionRefundsExecute(r)
}

/*
 * ListTransactionRefunds List transaction refunds
 * Lists all refunds associated with a certain transaction.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @return ApiListTransactionRefundsRequest
 */
func (a *TransactionsApiService) ListTransactionRefunds(ctx _context.Context, transactionId string) ApiListTransactionRefundsRequest {
	return ApiListTransactionRefundsRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

/*
 * Execute executes the request
 * @return Refunds
 */
func (a *TransactionsApiService) ListTransactionRefundsExecute(r ApiListTransactionRefundsRequest) (Refunds, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Refunds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.ListTransactionRefunds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}/refunds"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	buyerExternalIdentifier *string
	buyerId *string
	cursor *string
	limit *int32
	amountEq *int32
	amountGte *int32
	amountLte *int32
	createdAtGte *time.Time
	createdAtLte *time.Time
	currency *[]string
	externalIdentifier *string
	hasRefunds *bool
	id *string
	metadata *[]string
	method *[]string
	paymentMethodId *string
	paymentServiceId *[]string
	paymentServiceTransactionId *string
	search *string
	status *[]string
	updatedAtGte *time.Time
	updatedAtLte *time.Time
	beforeCreatedAt *time.Time
	afterCreatedAt *time.Time
	beforeUpdatedAt *time.Time
	afterUpdatedAt *time.Time
	transactionStatus *string
}

func (r ApiListTransactionsRequest) BuyerExternalIdentifier(buyerExternalIdentifier string) ApiListTransactionsRequest {
	r.buyerExternalIdentifier = &buyerExternalIdentifier
	return r
}
func (r ApiListTransactionsRequest) BuyerId(buyerId string) ApiListTransactionsRequest {
	r.buyerId = &buyerId
	return r
}
func (r ApiListTransactionsRequest) Cursor(cursor string) ApiListTransactionsRequest {
	r.cursor = &cursor
	return r
}
func (r ApiListTransactionsRequest) Limit(limit int32) ApiListTransactionsRequest {
	r.limit = &limit
	return r
}
func (r ApiListTransactionsRequest) AmountEq(amountEq int32) ApiListTransactionsRequest {
	r.amountEq = &amountEq
	return r
}
func (r ApiListTransactionsRequest) AmountGte(amountGte int32) ApiListTransactionsRequest {
	r.amountGte = &amountGte
	return r
}
func (r ApiListTransactionsRequest) AmountLte(amountLte int32) ApiListTransactionsRequest {
	r.amountLte = &amountLte
	return r
}
func (r ApiListTransactionsRequest) CreatedAtGte(createdAtGte time.Time) ApiListTransactionsRequest {
	r.createdAtGte = &createdAtGte
	return r
}
func (r ApiListTransactionsRequest) CreatedAtLte(createdAtLte time.Time) ApiListTransactionsRequest {
	r.createdAtLte = &createdAtLte
	return r
}
func (r ApiListTransactionsRequest) Currency(currency []string) ApiListTransactionsRequest {
	r.currency = &currency
	return r
}
func (r ApiListTransactionsRequest) ExternalIdentifier(externalIdentifier string) ApiListTransactionsRequest {
	r.externalIdentifier = &externalIdentifier
	return r
}
func (r ApiListTransactionsRequest) HasRefunds(hasRefunds bool) ApiListTransactionsRequest {
	r.hasRefunds = &hasRefunds
	return r
}
func (r ApiListTransactionsRequest) Id(id string) ApiListTransactionsRequest {
	r.id = &id
	return r
}
func (r ApiListTransactionsRequest) Metadata(metadata []string) ApiListTransactionsRequest {
	r.metadata = &metadata
	return r
}
func (r ApiListTransactionsRequest) Method(method []string) ApiListTransactionsRequest {
	r.method = &method
	return r
}
func (r ApiListTransactionsRequest) PaymentMethodId(paymentMethodId string) ApiListTransactionsRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}
func (r ApiListTransactionsRequest) PaymentServiceId(paymentServiceId []string) ApiListTransactionsRequest {
	r.paymentServiceId = &paymentServiceId
	return r
}
func (r ApiListTransactionsRequest) PaymentServiceTransactionId(paymentServiceTransactionId string) ApiListTransactionsRequest {
	r.paymentServiceTransactionId = &paymentServiceTransactionId
	return r
}
func (r ApiListTransactionsRequest) Search(search string) ApiListTransactionsRequest {
	r.search = &search
	return r
}
func (r ApiListTransactionsRequest) Status(status []string) ApiListTransactionsRequest {
	r.status = &status
	return r
}
func (r ApiListTransactionsRequest) UpdatedAtGte(updatedAtGte time.Time) ApiListTransactionsRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}
func (r ApiListTransactionsRequest) UpdatedAtLte(updatedAtLte time.Time) ApiListTransactionsRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}
func (r ApiListTransactionsRequest) BeforeCreatedAt(beforeCreatedAt time.Time) ApiListTransactionsRequest {
	r.beforeCreatedAt = &beforeCreatedAt
	return r
}
func (r ApiListTransactionsRequest) AfterCreatedAt(afterCreatedAt time.Time) ApiListTransactionsRequest {
	r.afterCreatedAt = &afterCreatedAt
	return r
}
func (r ApiListTransactionsRequest) BeforeUpdatedAt(beforeUpdatedAt time.Time) ApiListTransactionsRequest {
	r.beforeUpdatedAt = &beforeUpdatedAt
	return r
}
func (r ApiListTransactionsRequest) AfterUpdatedAt(afterUpdatedAt time.Time) ApiListTransactionsRequest {
	r.afterUpdatedAt = &afterUpdatedAt
	return r
}
func (r ApiListTransactionsRequest) TransactionStatus(transactionStatus string) ApiListTransactionsRequest {
	r.transactionStatus = &transactionStatus
	return r
}

func (r ApiListTransactionsRequest) Execute() (Transactions, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionsExecute(r)
}

/*
 * ListTransactions List transactions
 * Lists all transactions for an account. Sorted by last `updated_at` status.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListTransactionsRequest
 */
func (a *TransactionsApiService) ListTransactions(ctx _context.Context) ApiListTransactionsRequest {
	return ApiListTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Transactions
 */
func (a *TransactionsApiService) ListTransactionsExecute(r ApiListTransactionsRequest) (Transactions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.ListTransactions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.buyerExternalIdentifier != nil {
		localVarQueryParams.Add("buyer_external_identifier", parameterToString(*r.buyerExternalIdentifier, ""))
	}
	if r.buyerId != nil {
		localVarQueryParams.Add("buyer_id", parameterToString(*r.buyerId, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.amountEq != nil {
		localVarQueryParams.Add("amount_eq", parameterToString(*r.amountEq, ""))
	}
	if r.amountGte != nil {
		localVarQueryParams.Add("amount_gte", parameterToString(*r.amountGte, ""))
	}
	if r.amountLte != nil {
		localVarQueryParams.Add("amount_lte", parameterToString(*r.amountLte, ""))
	}
	if r.createdAtGte != nil {
		localVarQueryParams.Add("created_at_gte", parameterToString(*r.createdAtGte, ""))
	}
	if r.createdAtLte != nil {
		localVarQueryParams.Add("created_at_lte", parameterToString(*r.createdAtLte, ""))
	}
	if r.currency != nil {
		t := *r.currency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("currency", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("currency", parameterToString(t, "multi"))
		}
	}
	if r.externalIdentifier != nil {
		localVarQueryParams.Add("external_identifier", parameterToString(*r.externalIdentifier, ""))
	}
	if r.hasRefunds != nil {
		localVarQueryParams.Add("has_refunds", parameterToString(*r.hasRefunds, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.metadata != nil {
		t := *r.metadata
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("metadata", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("metadata", parameterToString(t, "multi"))
		}
	}
	if r.method != nil {
		t := *r.method
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("method", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("method", parameterToString(t, "multi"))
		}
	}
	if r.paymentMethodId != nil {
		localVarQueryParams.Add("payment_method_id", parameterToString(*r.paymentMethodId, ""))
	}
	if r.paymentServiceId != nil {
		t := *r.paymentServiceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("payment_service_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("payment_service_id", parameterToString(t, "multi"))
		}
	}
	if r.paymentServiceTransactionId != nil {
		localVarQueryParams.Add("payment_service_transaction_id", parameterToString(*r.paymentServiceTransactionId, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.updatedAtGte != nil {
		localVarQueryParams.Add("updated_at_gte", parameterToString(*r.updatedAtGte, ""))
	}
	if r.updatedAtLte != nil {
		localVarQueryParams.Add("updated_at_lte", parameterToString(*r.updatedAtLte, ""))
	}
	if r.beforeCreatedAt != nil {
		localVarQueryParams.Add("before_created_at", parameterToString(*r.beforeCreatedAt, ""))
	}
	if r.afterCreatedAt != nil {
		localVarQueryParams.Add("after_created_at", parameterToString(*r.afterCreatedAt, ""))
	}
	if r.beforeUpdatedAt != nil {
		localVarQueryParams.Add("before_updated_at", parameterToString(*r.beforeUpdatedAt, ""))
	}
	if r.afterUpdatedAt != nil {
		localVarQueryParams.Add("after_updated_at", parameterToString(*r.afterUpdatedAt, ""))
	}
	if r.transactionStatus != nil {
		localVarQueryParams.Add("transaction_status", parameterToString(*r.transactionStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundTransactionRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
	transactionRefundRequest *TransactionRefundRequest
}

func (r ApiRefundTransactionRequest) TransactionRefundRequest(transactionRefundRequest TransactionRefundRequest) ApiRefundTransactionRequest {
	r.transactionRefundRequest = &transactionRefundRequest
	return r
}

func (r ApiRefundTransactionRequest) Execute() (Refund, *_nethttp.Response, error) {
	return r.ApiService.RefundTransactionExecute(r)
}

/*
 * RefundTransaction Refund transaction
 * Refunds a transaction, fully or partially.

If the transaction was not yet successfully captured, the
refund will not be processed. Authorized transactions can be
[voided](#operation/void-transaction) instead.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @return ApiRefundTransactionRequest
 */
func (a *TransactionsApiService) RefundTransaction(ctx _context.Context, transactionId string) ApiRefundTransactionRequest {
	return ApiRefundTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

/*
 * Execute executes the request
 * @return Refund
 */
func (a *TransactionsApiService) RefundTransactionExecute(r ApiRefundTransactionRequest) (Refund, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Refund
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.RefundTransaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}/refunds"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionRefundRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVoidTransactionRequest struct {
	ctx _context.Context
	ApiService *TransactionsApiService
	transactionId string
}


func (r ApiVoidTransactionRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.VoidTransactionExecute(r)
}

/*
 * VoidTransaction Void transaction
 * Voids a transaction.

If the transaction was not yet successfully authorized, or was already
captured, the void will not be processed. Captured transactions can be
[refunded](#operation/refund-transaction) instead.

Voiding zero-amount authorized transactions is not supported.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionId The ID for the transaction to get the information for.
 * @return ApiVoidTransactionRequest
 */
func (a *TransactionsApiService) VoidTransaction(ctx _context.Context, transactionId string) ApiVoidTransactionRequest {
	return ApiVoidTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *TransactionsApiService) VoidTransactionExecute(r ApiVoidTransactionRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.VoidTransaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transaction_id}/void"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", _neturl.PathEscape(parameterToString(r.transactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorGeneric
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error401Unauthorized
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error404NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
