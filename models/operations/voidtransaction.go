// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"errors"
	"fmt"
	"github.com/gr4vy/gr4vy-go/internal/utils"
	"github.com/gr4vy/gr4vy-go/models/components"
)

type VoidTransactionGlobals struct {
	MerchantAccountID *string `header:"style=simple,explode=false,name=x-gr4vy-merchant-account-id"`
}

func (v *VoidTransactionGlobals) GetMerchantAccountID() *string {
	if v == nil {
		return nil
	}
	return v.MerchantAccountID
}

type VoidTransactionRequest struct {
	// The ID of the transaction
	TransactionID string `pathParam:"style=simple,explode=false,name=transaction_id"`
	// The preferred resource type in the response.
	Prefer []string `header:"style=simple,explode=false,name=prefer"`
	// The ID of the merchant account to use for this request.
	MerchantAccountID *string `header:"style=simple,explode=false,name=x-gr4vy-merchant-account-id"`
	// A unique key that identifies this request. Providing this header will make this an idempotent request. We recommend using V4 UUIDs, or another random string with enough entropy to avoid collisions.
	IdempotencyKey *string `header:"style=simple,explode=false,name=idempotency-key"`
}

func (v *VoidTransactionRequest) GetTransactionID() string {
	if v == nil {
		return ""
	}
	return v.TransactionID
}

func (v *VoidTransactionRequest) GetPrefer() []string {
	if v == nil {
		return nil
	}
	return v.Prefer
}

func (v *VoidTransactionRequest) GetMerchantAccountID() *string {
	if v == nil {
		return nil
	}
	return v.MerchantAccountID
}

func (v *VoidTransactionRequest) GetIdempotencyKey() *string {
	if v == nil {
		return nil
	}
	return v.IdempotencyKey
}

type Response200VoidTransactionType string

const (
	Response200VoidTransactionTypeTransaction     Response200VoidTransactionType = "Transaction"
	Response200VoidTransactionTypeTransactionVoid Response200VoidTransactionType = "TransactionVoid"
)

// Response200VoidTransaction - Successful Response
type Response200VoidTransaction struct {
	Transaction     *components.Transaction     `queryParam:"inline" union:"member"`
	TransactionVoid *components.TransactionVoid `queryParam:"inline" union:"member"`

	Type Response200VoidTransactionType
}

func CreateResponse200VoidTransactionTransaction(transaction components.Transaction) Response200VoidTransaction {
	typ := Response200VoidTransactionTypeTransaction

	return Response200VoidTransaction{
		Transaction: &transaction,
		Type:        typ,
	}
}

func CreateResponse200VoidTransactionTransactionVoid(transactionVoid components.TransactionVoid) Response200VoidTransaction {
	typ := Response200VoidTransactionTypeTransactionVoid

	return Response200VoidTransaction{
		TransactionVoid: &transactionVoid,
		Type:            typ,
	}
}

func (u *Response200VoidTransaction) UnmarshalJSON(data []byte) error {

	var transaction components.Transaction = components.Transaction{}
	if err := utils.UnmarshalJSON(data, &transaction, "", true, nil); err == nil {
		u.Transaction = &transaction
		u.Type = Response200VoidTransactionTypeTransaction
		return nil
	}

	var transactionVoid components.TransactionVoid = components.TransactionVoid{}
	if err := utils.UnmarshalJSON(data, &transactionVoid, "", true, nil); err == nil {
		u.TransactionVoid = &transactionVoid
		u.Type = Response200VoidTransactionTypeTransactionVoid
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Response200VoidTransaction", string(data))
}

func (u Response200VoidTransaction) MarshalJSON() ([]byte, error) {
	if u.Transaction != nil {
		return utils.MarshalJSON(u.Transaction, "", true)
	}

	if u.TransactionVoid != nil {
		return utils.MarshalJSON(u.TransactionVoid, "", true)
	}

	return nil, errors.New("could not marshal union type Response200VoidTransaction: all fields are null")
}
